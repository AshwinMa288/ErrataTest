---
title: "[MS-WINERRATA]: Server Message Block (SMB) Protocol Versions 2 and 3"
description: "This topic lists the Errata found in [MS-SMB2]    since it was last published. Since this topic is updated frequently, we    recommend that you"
---

# [MS-SMB2]: Server Message Block (SMB) Protocol Versions 2 and 3

<p align="right"><a href="https://msdn.microsoft.com/en-us/library/2cdafcfa-ce51-426a-9678-630a505a1a35">msdn link</a></p>
<p> </p>

<table>
 <thead>
  <tr>
   <th>
   <p>This topic lists the Errata found in [MS-SMB2]
   since it was last published. Since this topic is updated frequently, we
   recommend that you subscribe to these RSS or Atom feeds to receive update
   notifications.</p>
   <p>Errata are subject to the same terms as the
   Open Specifications documentation referenced.</p>
   </th>
   <th>
   <p><img id="Picture 19" src="ms-winerrata_files/image001.png"><a href="http://blogs.msdn.com/b/protocol_content_errata/rss.aspx">RSS</a> </p>
   <p><img id="Picture 20" src="ms-winerrata_files/image001.png"><a href="http://blogs.msdn.com/b/protocol_content_errata/atom.aspx">Atom</a> </p>
   <p> </p>
   </th>
  </tr>
 </thead>
</table>

<p>To view a PDF file of the errata for the previous versions
of this document, see the following ERRATA Archives:</p>

<p>March 4, 2020 - <a href="https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-WINERRATA/%5bMS-WINERRATA%5d-200304.pdf">Download</a></p>

<p><b>Rollup of Errata from March 5, 2020 – August 3, 2020 - </b><a href="https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-SMB2/%5bMS-SMB2%5d_200803_errata_diff.pdf"><b>Download</b></a></p>

<p>Errata below are for Protocol Document Version <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/5606ad47-5ee0-437a-817e-70c366052962">V60.0
– 2020/03/04</a>.</p>

<table>
 <thead>
  <tr>
   <th>
   <p>Errata Published*</p>
   </th>
   <th>
   <p>Description</p>
   </th>
  </tr>
 </thead>
 <tr>
  <td>
  <p>2020/08/03</p>
  </td>
  <td>
  <p>In Section 3.3.4.13, Server Application Registers a
  Share the following was changed from:</p>
  <p> </p>
  <p>&#9679;   Share.Type MUST be set to shi503_type. The
  server SHOULD&lt;212&gt; set STYPE_CLUSTER_FS, STYPE_CLUSTER_SOFS, and
  STYPE_CLUSTER_DFS in an implementation-defined manner.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   Share.Type MUST be set to shi503_type. The
  server SHOULD&lt;212&gt; set STYPE_CLUSTER_FS, STYPE_CLUSTER_SOFS, and
  STYPE_CLUSTER_DFS as specified in [MS-SRVS] section 2.2.2.4 in an
  implementation-defined manner.</p>
  <p> </p>
  <p>In Section 3.3.5.7, Receiving an SMB2 TREE_CONNECT
  Request the following was changed from:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>If Share.Type includes STYPE_CLUSTER_FS,
  STYPE_CLUSTER_SOFS, or STYPE_CLUSTER_DFS and Connection.Dialect is greater
  than MaxClusterDialect and SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT is not
  set in Flags/Reserved field, the server MUST fail the request with
  STATUS_SMB_BAD_CLUSTER_DIALECT (0xC05D0001) and if Connection.Dialect is SMB
  3.1.1, the server MUST return error data as specified in section 2.2.2 with
  ByteCount set to 10, ErrorContextCount set to 1, and ErrorData set to SMB2
  ERROR Context response formatted as ErrorDataLength set to 2, ErrorId set to
  0, and ErrorData set to MaxClusterDialect; otherwise, the server MUST return
  error data as specified in section 2.2.2 with ByteCount set to 2 and
  ErrorContextData set to MaxClusterDialect.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>...</p>
  <p>If Share.Type is STYPE_CLUSTER_FS, STYPE_CLUSTER_SOFS,
  or STYPE_CLUSTER_DFS as specified in [MS-SRVS] section 2.2.2.4 and
  Connection.Dialect is greater than MaxClusterDialect and
  SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT is not set in Flags/Reserved field,
  the server MUST fail the request with STATUS_SMB_BAD_CLUSTER_DIALECT
  (0xC05D0001) and if Connection.Dialect is SMB 3.1.1, the server MUST return
  error data as specified in section 2.2.2 with ByteCount set to 10, ErrorContextCount
  set to 1, and ErrorData set to SMB2 ERROR Context response formatted as
  ErrorDataLength set to 2, ErrorId set to 0, and ErrorData set to
  MaxClusterDialect; otherwise, the server MUST return error data as specified
  in section 2.2.2 with ByteCount set to 2 and ErrorContextData set to
  MaxClusterDialect.</p>
  <p> </p>
  <p>.</p>
  <p> </p>
  <p>Changed from:</p>
  <p> </p>
  <p>If TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS,
  Connection.Dialect is &quot;3.1.1&quot; and the SMB2
  _TREE_CONNECT_FLAG_REDIRECT_TO_OWNER bit is set in the Flags field of the
  SMB2 TREE_CONNECT request, the server MUST query the underlying object store
  in an implementation-specific manner to determine whether the share is hosted
  on this node. If not, the server MUST fail the tree connect request by
  setting the Status field in SMB2 header to STATUS_BAD_NETWORK_NAME, return
  error data as specified in section 2.2.2 with ErrorData set to SMB2 ERROR
  Context response formatted as ErrorId set to SMB2_ERROR_ID_SHARE_REDIRECT,
  and ErrorContextData set to the Share Redirect error context data as specified
  in section 2.2.2.2.2 with IPAddrMoveList set to the list of IP addresses
  determined for where to access the share.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as
  specified in [MS-SRVS] section 2.2.2.4, Connection.Dialect is
  &quot;3.1.1&quot; and the SMB2 _TREE_CONNECT_FLAG_REDIRECT_TO_OWNER bit is
  set in the Flags field of the SMB2 TREE_CONNECT request, the server MUST
  query the underlying object store in an implementation-specific manner to
  determine whether the share is hosted on this node. If not, the server MUST
  fail the tree connect request by setting the Status field in SMB2 header to
  STATUS_BAD_NETWORK_NAME, return error data as specified in section 2.2.2 with
  ErrorData set to SMB2 ERROR Context response formatted as ErrorId set to SMB2_ERROR_ID_SHARE_REDIRECT,
  and ErrorContextData set to the Share Redirect error context data as
  specified in section 2.2.2.2.2 with IPAddrMoveList set to the list of IP
  addresses determined for where to access the share.</p>
  <p> </p>
  <p>Changed from:</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family and TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS, the
  server MUST set the SMB2_SHARE_CAP_SCALEOUT bit in the Capabilities field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family and TreeConnect.Share.Type includes STYPE_CLUSTER_FS,
  STYPE_CLUSTER_SOFS, or STYPE_CLUSTER_DFS the server MUST set the
  SMB2_SHARE_CAP_CLUSTER bit in the Capabilities field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.0.2&quot;
  or &quot;3.1.1&quot;, TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS, and
  TreeConnect.Share is asymmetric, the server MUST set the
  SMB2_SHARE_CAP_ASYMMETRIC bit in the Capabilities field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.1.1&quot;
  and TreeConnect.Share.SupportsIdentityRemoting is set, the server MUST set
  the SMB2_SHAREFLAG_IDENTITY_REMOTING bit in the ShareFlags field of the SMB2
  TREE_CONNECT response.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.1.1&quot;,
  TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS, and the
  SMB2_TREE_CONNECT_FLAG_REDIRECT_TO_OWNER bit is set in the Flags field of the
  SMB2 TREE_CONNECT request and the SMB2_SHARE _CAP_ASYMMETRIC bit is set in
  the Capabilities field, the server SHOULD&lt;259&gt; set the
  SMB2_SHARE_CAP_REDIRECT_TO_OWNER bit in the Capabilities field.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family and TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as specified
  in [MS-SRVS] section 2.2.2.4, the server MUST set the SMB2_SHARE_CAP_SCALEOUT
  bit in the Capabilities field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family and TreeConnect.Share.Type is STYPE_CLUSTER_FS,
  STYPE_CLUSTER_SOFS, or STYPE_CLUSTER_DFS as specified in [MS-SRVS] section
  2.2.2.4, the server MUST set the SMB2_SHARE_CAP_CLUSTER bit in the
  Capabilities field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.0.2&quot;
  or &quot;3.1.1&quot;, TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as
  specified in [MS-SRVS] section 2.2.2.4, and TreeConnect.Share is asymmetric,
  the server MUST set the SMB2_SHARE_CAP_ASYMMETRIC bit in the Capabilities
  field.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.1.1&quot;
  and TreeConnect.Share.SupportsIdentityRemoting is set, the server MUST set
  the SMB2_SHAREFLAG_IDENTITY_REMOTING bit in the ShareFlags field of the SMB2
  TREE_CONNECT response.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect is &quot;3.1.1&quot;,
  TreeConnect.Share.Type sis STYPE_CLUSTER_SOFS as specified in [MS-SRVS]
  section 2.2.2.4, and the SMB2_TREE_CONNECT_FLAG_REDIRECT_TO_OWNER bit is set
  in the Flags field of the SMB2 TREE_CONNECT request and the SMB2_SHARE
  _CAP_ASYMMETRIC bit is set in the Capabilities field, the server SHOULD&lt;259&gt;
  set the SMB2_SHARE_CAP_REDIRECT_TO_OWNER bit in the Capabilities field.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>In Section 3.3.5.9, Receiving an SMB2 CREATE Request
  the following has been changed from:</p>
  <p> </p>
  <p>&#9679;   The Treeconnect.Share.Type is STYPE_DISKTREE</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   The Treeconnect.Share.Type is STYPE_DISKTREE
  as specified in [MS-SRVS] section 2.2.2.4.</p>
  <p> </p>
  <p>Changed from:</p>
  <p> </p>
  <p>For open requests on a share of type STYPE_DISKTREE
  (as indicated by TreeConnect.Share.Type) the server MUST do the following:</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If TreeConnect.Share.Type is STYPE_DISKTREE as
  specified in [MS-SRVS] section 2.2.2.4, the server MUST do the following:</p>
  <p> </p>
  <p>Changed from:</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS and the
  RequestedOplockLevel is SMB2_OPLOCK_LEVEL_BATCH, the server MUST set
  RequestedOplockLevel to SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>If CreateOptions includes
  FILE_NO_INTERMEDIATE_BUFFERING and DesiredAccess includes FILE_APPEND_DATA,
  the server MUST set FILE_APPEND_DATA to zero in the DesiredAccess field in
  the request.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as specified in
  [MS-SRVS] section 2.2.2.4, and the RequestedOplockLevel is
  SMB2_OPLOCK_LEVEL_BATCH, the server MUST set RequestedOplockLevel to
  SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>If CreateOptions includes
  FILE_NO_INTERMEDIATE_BUFFERING the server MUST set FILE_APPEND_DATA to zero
  in the DesiredAccess field in the request.</p>
  <p> </p>
  <p>In Section 3.3.5.9.8, Handling the SMB2_CREATE_REQUEST_LEASE
  Create Context the following was changed from:</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS and if LeaseState
  includes SMB2_LEASE_READ_CACHING, the server MUST set LeaseState to
  SMB2_LEASE_READ_CACHING, otherwise set LeaseState to SMB2_LEASE_NONE.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as specified in
  [MS-SRVS] section 2.2.2.4, and if LeaseState includes
  SMB2_LEASE_READ_CACHING, the server MUST set LeaseState to
  SMB2_LEASE_READ_CACHING, otherwise set LeaseState to SMB2_LEASE_NONE.</p>
  <p> </p>
  <p>In Section 3.3.5.9.11   Handling the
  SMB2_CREATE_REQUEST_LEASE_V2 Create Context the following was changed from:</p>
  <p> </p>
  <p>If TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS
  and if LeaseState includes SMB2_LEASE_READ_CACHING, the server MUST set
  LeaseState to SMB2_LEASE_READ_CACHING, otherwise set LeaseState to
  SMB2_LEASE_NONE.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If TreeConnect.Share.Type is STYPE_CLUSTER_SOFS as
  specified in [MS-SRVS] section 2.2.2.4, and if LeaseState includes
  SMB2_LEASE_READ_CACHING, the server MUST set LeaseState to
  SMB2_LEASE_READ_CACHING, otherwise set LeaseState to SMB2_LEASE_NONE.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/08/03</p>
  </td>
  <td>
  <p>In Section 3.3.5.9, Receiving an SMB2 CREATE Request,
  the following was changed from:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>For open requests on a share of type STYPE_DISKTREE
  (as indicated by TreeConnect.Share.Type), the server MUST do the following:</p>
  <p> </p>
  <p>&#9679;   If TreeConnect.Share.RestrictExclusiveOpens
  is TRUE and the ShareAccess field does not include FILE_SHARE_READ, and the
  DesiredAccess field does not include GENERIC_ALL, GENERIC_WRITE,
  FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, or FILE_APPEND_DATA,
  the server SHOULD&lt;261&gt; set FILE_SHARE_READ in the ShareAccess field.</p>
  <p> </p>
  <p>&#9679;   If TreeConnect.Share.ForceSharedDelete is
  TRUE, the server MUST set FILE_SHARE_DELETE in the ShareAccess field.</p>
  <p> </p>
  <p>&#9679;   f TreeConnect.Share.ForceLevel2Oplock is
  TRUE, and RequestedOplockLevel is SMB2_OPLOCK_LEVEL_BATCH or SMB2_OPLOCK_LEVEL_EXCLUSIVE,
  the server SHOULD&lt;263&gt; set RequestedOplockLevel to
  SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS and the
  RequestedOplockLevel is SMB2_OPLOCK_LEVEL_BATCH, the server MUST set
  RequestedOplockLevel to SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>&#9679;   If CreateOptions includes
  FILE_NO_INTERMEDIATE_BUFFERING and DesiredAccess includes FILE_APPEND_DATA,
  the server MUST set FILE_APPEND_DATA to zero in the DesiredAccess field in
  the request.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679;   Open.LocalOpen is set to the open of the
  object in the local resource received as part of the local create operation.</p>
  <p> </p>
  <p>&#9679;   Open.GrantedAccess is the access granted to
  the caller for the open by the underlying object store. It MUST be equal to
  the DesiredAccess specified in the request, except in the case where
  MAXIMUM_ALLOWED is included in the DesiredAccess.</p>
  <p> </p>
  <p>&#9679;   If Open.GrantedAccess includes FILE_EXECUTE,
  the server MUST set FILE_READ_DATA in Open.GrantedAccess.</p>
  <p> </p>
  <p>&#9679;   Open.OplockLevel is set to
  SMB2_OPLOCK_LEVEL_NONE.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>For open requests on a share of type STYPE_DISKTREE
  (as indicated by TreeConnect.Share.Type), the server MUST do the following:</p>
  <p> </p>
  <p>&#9679;   If DesiredAccess is zero, the server SHOULD&lt;260&gt;
  fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>&#9679;   If TreeConnect.Share.RestrictExclusiveOpens
  is TRUE and the ShareAccess field does not include FILE_SHARE_READ, and the
  DesiredAccess field does not include GENERIC_ALL, GENERIC_WRITE, FILE_WRITE_DATA,
  FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, or FILE_APPEND_DATA, the server
  SHOULD&lt;261&gt; set FILE_SHARE_READ in the ShareAccess field.</p>
  <p> </p>
  <p>&#9679;   If TreeConnect.Share.ForceSharedDelete is
  TRUE, the server MUST set FILE_SHARE_DELETE in the ShareAccess field.</p>
  <p> </p>
  <p>&#9679;   If DesiredAccess is not equal to
  TreeConnect.MaximalAccess and TreeConnect.Share.ConnectSecurity is not empty,
  the server MUST perform as below:</p>
  <p> </p>
  <p>&#9679;   Clear ACCESS_SYSTEM_SECURITY in
  DesiredAccess. If DesiredAccess is zero, the server MUST fail the request with
  STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>&#9679;   If Session.SecurityContext is empty, the
  server MUST fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>&#9679;   The server MUST perform access check for the
  share in the underlying object store using the parameters Session.SecurityContext,
  TreeConnect.Share.ConnectSecurity and DesiredAccess.&lt;262&gt; If the
  underlying object store returns a failure, the server MUST fail the request
  with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>&#9679;   If TreeConnect.Share.ForceLevel2Oplock is
  TRUE, and RequestedOplockLevel is SMB2_OPLOCK_LEVEL_BATCH or
  SMB2_OPLOCK_LEVEL_EXCLUSIVE, the server SHOULD&lt;263&gt; set
  RequestedOplockLevel to SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>&#9679;   If Connection.Dialect belongs to the SMB 3.x
  dialect family TreeConnect.Share.Type includes STYPE_CLUSTER_SOFS and the
  RequestedOplockLevel is SMB2_OPLOCK_LEVEL_BATCH, the server MUST set
  RequestedOplockLevel to SMB2_OPLOCK_LEVEL_II.</p>
  <p> </p>
  <p>&#9679;   If CreateOptions includes
  FILE_NO_INTERMEDIATE_BUFFERING and DesiredAccess includes FILE_APPEND_DATA,
  the server MUST set FILE_APPEND_DATA to zero in the DesiredAccess field in
  the request.</p>
  <p> </p>
  <p>&lt;260&gt; Section 3.3.5.9: Windows Vista, Windows
  Server 2008, Windows 7, and Windows Server 2008 R2 operating systems do not
  perform this verification and continue to process the request.</p>
  <p> </p>
  <p>&lt;262&gt; Section 3.3.5.9: Windows performs the
  access check by mapping SMB2 parameters to the object store parameters as
  described in [MS-FSA] section 2.1.4.14 AccessCheck -- Algorithm to Perform a
  General Access Check.</p>
  <p> </p>
  <p>Object Store parameter   SMB2 parameter</p>
  <p> </p>
  <p>SecurityContext   Session.SecurityContext</p>
  <p> </p>
  <p>SecurityDescriptor   TreeConnect.Share.ConnectSecurity</p>
  <p> </p>
  <p>DesiredAccess   DesiredAccess</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679;   Open.LocalOpen is set to the open of the
  object in the local resource received as part of the local create operation.</p>
  <p> </p>
  <p>&#9679;   If DesiredAccess is equal to
  TreeConnect.MaximalAccess, the server MUST set Open.GrantedAccess to
  TreeConnect.MaximalAccess.</p>
  <p> </p>
  <p>&#9679;   If DesiredAccess is not equal to
  TreeConnect.MaximalAccess and TreeConnect.Share.ConnectSecurity is empty, the
  server MUST set Open.GrantedAccess to FILE_ALL_ACCESS.</p>
  <p> </p>
  <p>Otherwise,</p>
  <p> </p>
  <p>If MAXIMUM_ALLOWED is not included in the
  DesiredAccess, the server MUST set Open.GrantedAccess to the DesiredAccess
  specified in the request. Otherwise, the server MUST set Open.GrantedAccess
  to DesiredAccess with GENERIC_ALL set.</p>
  <p> </p>
  <p>&#9679;   If DesiredAccess received in the request
  includes ACCESS_SYSTEM_SECURITY, the server MUST set ACCESS_SYSTEM_SECURITY
  in Open.GrantedAccess.</p>
  <p> </p>
  <p>&#9679;   If Open.GrantedAccess includes FILE_EXECUTE,
  the server MUST set FILE_READ_DATA in Open.GrantedAccess.</p>
  <p> </p>
  <p>&#9679;   Open.OplockLevel is set to
  SMB2_OPLOCK_LEVEL_NONE.</p>
  <p> </p>
  <p>...</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/07/06</p>
  </td>
  <td>
  <p>In Section 2.2.42. SMB2 Compression_Transform_Header,
  updated the description for when the SMB2_COMPRESSION_FLAG_CHAINED is set.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>The SMB2 COMPRESSION_TRANSFORM_HEADER is used by the
  client or server when sending compressed messages. This optional header is
  only valid for the SMB 3.1.1 dialect&lt;70&gt;.</p>
  <p>Changed to:</p>
  <p>The SMB2 COMPRESSION_TRANSFORM_HEADER is used by the
  client or server when sending compressed messages. When
  SMB2_COMPRESSION_FLAG_CHAINED is set in Flags field, the 8 bytes comprising
  CompressionAlgorithm, Flags, and Length fields of this structure are
  interpreted as the first SMB2_COMPRESSION_PAYLOAD_HEADER, specified in
  section 2.2.42.1. This optional header is only valid for the SMB 3.1.1
  dialect&lt;70&gt;.</p>
  <p> </p>
  <p>In Section 2.2.42.1 SMB2_COMPRESSION_PAYLOAD_HEADER,
  renamed the AlgorithmId field to CompressionAlgorithm and the Reserved field
  to Flags.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>The SMB2_COMPRESSION_PAYLOAD_HEADER is used by the
  client or server when sending chained compressed payloads. This optional
  structure is only valid for the SMB 3.1.1 dialect&lt;71&gt;.</p>
  <p><img id="Picture 393" src="ms-winerrata_files/image006.png"></p>
  <p>Reserved (2 bytes): This field MUST NOT be used and
  MUST be reserved. The sender MUST set this to 0, and the receiver MUST ignore
  it.</p>
  <p>Length (4 bytes): The length, in bytes, of the
  compressed payload.</p>
  <p> </p>
  <p>OriginalPayloadSize (4 bytes): This optional field is
  present only when AlgorithmId is LZNT1, LZ77, or LZ77+Huffman. The size, in
  bytes, of the uncompressed payload.</p>
  <p> </p>
  <p>Changed to:</p>
  <p>The SMB2_COMPRESSION_PAYLOAD_HEADER is used by the
  client or server when sending chained compressed payloads. This optional
  structure is only valid for the SMB 3.1.1 dialect&lt;71&gt;.</p>
  <p><img id="Picture 394" src="ms-winerrata_files/image007.png"></p>
  <p>Flags (2 bytes): This field MUST be set to one of the
  following values:</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>Value</p>
     </th>
     <th>
     <p>Meaning</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>SMB2_COMPRESSION_FLAG_NONE<br><br></p>
    <p>0x0000</p>
    </td>
    <td>
    <p>Indicates that this is not the first payload header
    in a chain of compressed payloads.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_COMPRESSION_FLAG_CHAINED<br><br></p>
    <p>0x0001</p>
    </td>
    <td>
    <p>When set, indicates that this is the first payload
    header in a chain of compressed payloads.<br><br></p>
    <p> </p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p>Length (4 bytes): The length, in bytes, of the
  compressed payload including the size of OriginalPayloadSize field, if
  present.</p>
  <p> </p>
  <p>OriginalPayloadSize (4 bytes): This optional field is
  present only when CompressionAlgorithm is LZNT1, LZ77, or LZ77+Huffman. The
  size, in bytes, of the uncompressed payload.</p>
  <p> </p>
  <p>In Section 3.1.4.4 Compressing the Message, updated
  the processing rules for when the SMB2_COMPRESSION_PAYLOAD_HEADER is set in
  the Flags field.</p>
  <p> </p>
  <p>Changed from:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If RemainingUncompressedDataSize
  is greater than 1024, CompressedMessage MUST be appended with newly
  constructed SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to
  LZNT1, LZ77, or LZ77+Huffman specified in Connection.CompressionIds. The
  uncompressed data MUST be compressed using the algorithm specified in
  AlgorithmId as specified in [MS-XCA] section 2. Length MUST be set to the
  size of the compressed data. OriginalPayloadSize MUST be set to the size of
  the uncompressed data. CompressedMessage MUST be appended with the compressed
  data. RemainingUncompressedDataSize MUST be decremented by the size of data
  before compression. TotalCompressedDataSize MUST be incremented by the size
  of compressed data.</p>
</dd>
<dd>
<p>&#9679; Otherwise if
  RemainingUncompressedDataSize is greater than zero and (size of the
  uncompressed SMB2 message / RemainingUncompressedDataSize) is greater than 2,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to NONE. Length MUST
  be set to RemainingUncompressedDataSize. CompressedMessage MUST be appended
  with the uncompressed data. RemainingUncompressedDataSize MUST be decremented
  by the size of data before compression. TotalCompressedDataSize MUST be
  incremented by the size of compressed data.</p>
</dd>
<dd>
<p>&#9679; If BackwardDataPattern
  is not NULL and BackwardDataPattern.Repetitions is greater than zero,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with BackwardDataPattern.
  TotalCompressedDataSize MUST be incremented by
  BackwardDataPattern.Repetitions.</p>
</dd>
<dd>
<p>&#9679; If
  RemainingUncompressedDataSize is greater than zero, the sender MUST repeat
  step 2.</p>
</dd></dl></dd></dl>
  
  
  
  <p>&#9679;</p>
  <p>If TotalCompressedDataSize+8 is less than the size of
  uncompressed SMB2 message, the sender MUST prepend CompressedMessage with
  first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2
  message. The compressed SMB2 message is sent. Otherwise, the original,
  uncompressed SMB2 message is sent.</p>
  <p> </p>
  <p>Changed to:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If
  RemainingUncompressedDataSize is greater than 1024, CompressedMessage MUST be
  appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER.
  CompressionAlgorithm MUST be set to LZNT1, LZ77, or LZ77+Huffman specified in
  Connection.CompressionIds. The uncompressed data MUST be compressed using the
  algorithm specified in CompressionAlgorithm as specified in [MS-XCA] section
  2. Length MUST be set to sum of the size of the compressed data and the size
  of OriginalPayloadSize field. OriginalPayloadSize MUST be set to the size of
  the uncompressed data. CompressedMessage MUST be appended with the compressed
  data. RemainingUncompressedDataSize MUST be decremented by the size of data
  before compression. TotalCompressedDataSize MUST be incremented by the size
  of compressed data.</p>
</dd>
<dd>
<p>&#9679; Otherwise if
  RemainingUncompressedDataSize is greater than zero and (size of the
  uncompressed SMB2 message / RemainingUncompressedDataSize) is greater than 2,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. CompressionAlgorithm MUST be set to NONE.
  Length MUST be set to RemainingUncompressedDataSize. CompressedMessage MUST be
  appended with the uncompressed data. RemainingUncompressedDataSize MUST be
  decremented by the size of data before compression. TotalCompressedDataSize
  MUST be incremented by the size of compressed data.</p>
</dd>
<dd>
<p>&#9679; If
  BackwardDataPattern is not NULL and BackwardDataPattern.Repetitions is
  greater than zero, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. CompressionAlgorithm MUST be set to
  Pattern_V1. Length MUST be set to the size of
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1. CompressedMessage MUST be appended with
  BackwardDataPattern. TotalCompressedDataSize MUST be incremented by
  BackwardDataPattern.Repetitions.</p>
</dd>
<dd>
<p>&#9679; If
  RemainingUncompressedDataSize is greater than zero, the sender MUST repeat
  step 2.</p>
</dd></dl></dd></dl>
  
  
  
  <p>&#9679;</p>
  <p>If TotalCompressedDataSize+8 is less than the size of
  uncompressed SMB2 message, the sender MUST prepend CompressedMessage with
  first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2
  message. The Flags field in the first SMB2_COMPRESSION_PAYLOAD_HEADER MUST be
  set to SMB2_COMPRESSION_FLAG_CHAINED. The compressed SMB2 message is sent.
  Otherwise, the original, uncompressed SMB2 message is sent.</p>
  <p> </p>
  <p>In Section 3.1.5.3 Decompressing the Chained Message,
  updated the processing rules for compression.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>&#9679;</p>
  <p>The compressed data MUST be decompressed as follows:</p>
  <p>&#9679; The first 8 bytes of the data MUST be
  interpreted as SMB2_COMPRESSION_PAYLOAD_HEADER, specified in section
  2.2.42.1.</p>
  <p>&#9679; If AlgorithmId in SMB2_COMPRESSION_PAYLOAD_HEADER
  is not one of the values specified in section 2.2.3.1.3, the connection MUST
  be disconnected as specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679; If AlgorithmId in
  SMB2_COMPRESSION_PAYLOAD_HEADER is NONE:</p>
  <p>&#9679;</p>
  <p>If Length is greater than (the size of the received
  compressed message – 8) or OriginalCompressedSegmentSize inSMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679;</p>
  <p>Length number of bytes following
  SMB2_COMPRESSION_PAYLOAD_HEADER MUST be interpreted as uncompressed data and
  MUST be appended to DecompressedMessage.</p>
  <p>&#9679;</p>
  <p>Otherwise, the data MUST be decompressed as follows:</p>
  <p>&#9679;</p>
  <p>If AlgorithmId is Pattern_V1, the next 8 bytes MUST be
  interpreted as SMB2_COMPRESSION_PATTERN_PAYLOAD_V1, specified in section
  2.2.42.2.</p>
  <p>&#9679;</p>
  <p>If Repetitions in SMB2_COMPRESSION_PATTERN_PAYLOAD_V1
  is greater than OriginalCompressedSegmentSize inSMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679;</p>
  <p>Otherwise, DecompressedMessage MUST be appended with
  Repetitions number of bytes initialized with the character specified in
  Pattern field.</p>
  <p>&#9679;</p>
  <p>Otherwise, the data of size specified in Length field
  MUST be decompressed using the algorithm specified in AlgorithmId field as
  specified in [MS-XCA] section 2. If the size of the decompressed data is not
  equal to OriginalPayloadSize, the connection MUST be disconnected as
  specified in section 3.2.7.1 or section 3.3.7.1. DecompressedMessage MUST be
  appended with the decompressed data.</p>
  <p>&#9679;</p>
  <p>RemainingCompressedDataSize MUST be decremented by the
  size in Length field.</p>
  <p>&#9679;</p>
  <p>If the size of RemainingCompressedDataSize is greater
  than the size of SMB2_COMPRESSION_PAYLOAD_HEADER, the receiver MUST repeat
  step 2.</p>
  <p>&#9679;</p>
  <p>DecompressedMessage MUST be returned.</p>
  <p> </p>
  <p>Changed to:</p>
  <p>&#9679;</p>
  <p>The compressed data MUST be decompressed as follows:</p>
  <p>&#9679; The first 8 bytes of the data MUST be
  interpreted as SMB2_COMPRESSION_PAYLOAD_HEADER, specified in section
  2.2.42.1.</p>
  <p>&#9679; If CompressionAlgorithm in
  SMB2_COMPRESSION_PAYLOAD_HEADER is not one of the values specified in section
  2.2.3.1.3, the connection MUST be disconnected as specified in section
  3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679; If CompressionAlgorithm in
  SMB2_COMPRESSION_PAYLOAD_HEADER is NONE:</p>
  <p>&#9679;</p>
  <p>If Length is greater than (the size of the received
  compressed message – 8) or OriginalCompressedSegmentSize inSMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679;</p>
  <p>Length number of bytes following
  SMB2_COMPRESSION_PAYLOAD_HEADER MUST be interpreted as uncompressed data and
  MUST be appended to DecompressedMessage.</p>
  <p>&#9679;</p>
  <p>Otherwise, the data MUST be decompressed as follows:</p>
  <p>&#9679;</p>
  <p>If CompressionAlgorithm is Pattern_V1, the next 8
  bytes MUST be interpreted as SMB2_COMPRESSION_PATTERN_PAYLOAD_V1, specified
  in section 2.2.42.2.</p>
  <p>&#9679;</p>
  <p>If Repetitions in SMB2_COMPRESSION_PATTERN_PAYLOAD_V1
  is greater than OriginalCompressedSegmentSize inSMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p>&#9679;</p>
  <p>Otherwise, DecompressedMessage MUST be appended with
  Repetitions number of bytes initialized with the character specified in
  Pattern field.</p>
  <p>&#9679;</p>
  <p>Otherwise, the data of size specified in Length field
  minus size of OriginalPayloadSize field MUST be decompressed using the
  algorithm specified in CompressionAlgorithm field as specified in [MS-XCA]
  section 2. If the size of the decompressed data is not equal to
  OriginalPayloadSize, the connection MUST be disconnected as specified in
  section 3.2.7.1 or section 3.3.7.1. DecompressedMessage MUST be appended with
  the decompressed data.</p>
  <p>&#9679;</p>
  <p>RemainingCompressedDataSize MUST be decremented by the
  size in Length field.</p>
  <p>&#9679;</p>
  <p>If the size of RemainingCompressedDataSize is greater
  than the size of SMB2_COMPRESSION_PAYLOAD_HEADER, the receiver MUST repeat
  step 2.</p>
  <p>&#9679;</p>
  <p>DecompressedMessage MUST be returned.</p>
  <p> </p>
  <p> </p>
  <p>In Section 3.2.5.1.1.2 Decompressing the Message,
  updated the processing rules for compression.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>&#9679; The client MUST disconnect the connection as
  specified in section 3.2.7.1 if any of the following conditions are
  satisfied:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If the size of the
  message received from the server is less than the size of SMB2
  COMPRESSION_TRANSFORM_HEADER, specified in section 2.2.42.</p>
</dd>
<dd>
<p>&#9679; If
  Connection.CompressionIds does not contain CompressionAlgorithm in SMB2
  COMPRESSION_TRANSFORM_HEADER.</p>
</dd>
<dd>
<p>&#9679; If
  OriginalCompressedSegmentSize in the SMB2 COMPRESSION_TRANSFORM_HEADER is
  greater than the sum of (256, the size of SMB2 COMPRESSION_TRANSFORM_HEADER,
  largest of (Connection.MaxReadSize, Connection.MaxWriteSize,and
  Connection.MaxTransactSize)).</p>
</dd></dl></dd></dl>
  
  
  <p>Changed to:</p>
  <p>&#9679; The client MUST disconnect the connection as
  specified in section 3.2.7.1 if any of the following conditions are
  satisfied:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If the size of the
  message received from the server is less than the size of SMB2
  COMPRESSION_TRANSFORM_HEADER, specified in section 2.2.42.</p>
</dd>
<dd>
<p>&#9679; If Flags field in
  SMB2 COMPRESSION_TRANSFORM_HEADER is equal to SMB2_COMPRESSION_FLAG_NONE and
  Connection.CompressionIds does not contain CompressionAlgorithm in SMB2 COMPRESSION_TRANSFORM_HEADER.</p>
</dd>
<dd>
<p>&#9679; If
  OriginalCompressedSegmentSize in the SMB2 COMPRESSION_TRANSFORM_HEADER is
  greater than the sum of (256, the size of SMB2 COMPRESSION_TRANSFORM_HEADER,
  largest of (Connection.MaxReadSize, Connection.MaxWriteSize,and Connection.MaxTransactSize)).</p>
</dd></dl></dd></dl>
  
  
  <p> </p>
  <p>In Section 3.3.5.2.1.2 Decompressing the Message,
  updated the processing rules for compression.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>&#9679; The server MUST disconnect the connection as
  specified in section 3.3.7.1 if any of the following conditions are satisfied:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If the size of the
  message received from the client is less than the size of SMB2
  COMPRESSION_TRANSFORM_HEADER, specified in section 2.2.42.</p>
</dd>
<dd>
<p>&#9679; If
  Connection.CompressionIds does not contain the CompressionAlgorithm field in
  the SMB2 COMPRESSION_TRANSFORM_HEADER.</p>
</dd>
<dd>
<p>&#9679; If
  OriginalCompressedSegmentSize in the SMB2 COMPRESSION_TRANSFORM_HEADER is
  greater than the sum of (256, the size of SMB2 COMPRESSION_TRANSFORM_HEADER,
  largest of (Connection.MaxReadSize, Connection.MaxWriteSize,and
  Connection.MaxTransactSize)).</p>
</dd></dl></dd></dl>
  
  
  <p>Changed to:</p>
  <p>&#9679;The server MUST disconnect the connection as
  specified in section 3.3.7.1 if any of the following conditions are
  satisfied:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If the size of the
  message received from the client is less than the size of SMB2
  COMPRESSION_TRANSFORM_HEADER, specified in section 2.2.42.</p>
</dd>
<dd>
<p>&#9679; If Flags field in
  SMB2 COMPRESSION_TRANSFORM_HEADER is equal to SMB2_COMPRESSION_FLAG_NONE and
  Connection.CompressionIds does not contain the CompressionAlgorithm field in
  the SMB2 COMPRESSION_TRANSFORM_HEADER.</p>
</dd>
<dd>
<p>&#9679; If OriginalCompressedSegmentSize
  in the SMB2 COMPRESSION_TRANSFORM_HEADER is greater than the sum of (256, the
  size of SMB2 COMPRESSION_TRANSFORM_HEADER, largest of
  (Connection.MaxReadSize, Connection.MaxWriteSize,and
  Connection.MaxTransactSize)).</p>
</dd></dl></dd></dl>
  
  
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/22</p>
  </td>
  <td>
  <p>In Section 2.2.19, SMB2 READ Request, updated the
  description of the RemainingBytes field, adding the field to the value
  descriptions in the table for Channel.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>Channel (4 bytes): For SMB 2.0.2 and 2.1 dialects,
  this field MUST NOT be used and MUST be reserved. The client MUST set this
  field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect
  family, this field MUST contain exactly one of the following values:</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>Value</p>
     </th>
     <th>
     <p>Meaning</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>SMB2_CHANNEL_NONE<br><br></p>
    <p>0x00000000</p>
    </td>
    <td>
    <p>No channel information is present in the request.
    The ReadChannelInfoOffset and ReadChannelInfoLength fields MUST be  set to
    0 by the client and MUST be ignored by the server.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_CHANNEL_RDMA_V1<br><br></p>
    <p>0x00000001</p>
    </td>
    <td>
    <p>One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1
    structures as specified in [MS-SMBD] section 2.2.3.1 are present in the
    channel information specified by ReadChannelInfoOffset and
    ReadChannelInfoLength fields.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_CHANNEL_RDMA_V1_INVALIDATE<br><br></p>
    <p>0x00000002</p>
    </td>
    <td>
    <p>This flag is not valid for the SMB 3.0 dialect. One
    or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures, as specified in
    [MS-SMBD] section 2.2.3.1, are present in the channel information specified
    by the ReadChannelInfoOffset and ReadChannelInfoLength fields. The  server
    is requested to perform remote invalidation when responding to the  request
    as specified in [MS-SMBD] section 3.1.4.2.<br><br></p>
    <p>RemainingBytes (4 bytes): The number of subsequent
    bytes that the client intends to read from the file after this operation
    completes. This value is provided to facilitate read-ahead caching, and is
    not binding on the server.</p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p>Changed to:</p>
  <p>Channel (4 bytes): For SMB 2.0.2 and 2.1 dialects,
  this field MUST NOT be used and MUST be reserved. The client MUST set this
  field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect
  family, this field MUST contain exactly one of the following values:</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>Value</p>
     </th>
     <th>
     <p>Meaning</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>SMB2_CHANNEL_NONE<br><br></p>
    <p>0x00000000</p>
    </td>
    <td>
    <p>No channel information is present in the request.
    The RemainingBytes, ReadChannelInfoOffset, and ReadChannelInfoLength
    fields  MUST be set to 0 by the client and MUST be ignored by the server.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_CHANNEL_RDMA_V1<br><br></p>
    <p>0x00000001</p>
    </td>
    <td>
    <p>One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1
    structures as specified in [MS-SMBD] section 2.2.3.1 are present in the
    channel information specified by RemainingBytes,ReadChannelInfoOffset, and
    ReadChannelInfoLength fields.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_CHANNEL_RDMA_V1_INVALIDATE<br><br></p>
    <p>0x00000002</p>
    </td>
    <td>
    <p>This flag is not valid for the SMB 3.0 dialect. One
    or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures, as specified in
    [MS-SMBD] section 2.2.3.1, are present in the channel information specified
    by the RemainingBytes, ReadChannelInfoOffset, and ReadChannelInfoLength
    fields.  The server is requested to perform remote invalidation when
    responding to the  request as specified in [MS-SMBD] section 3.1.4.2.<br><br></p>
    <p>RemainingBytes (4 bytes): For the SMB 3.x dialect
    family, if the Channel field of the request contains SMB2_CHANNEL_RDMA_V1
    or SMB2_CHANNEL_RDMA_V1_INVALIDATE, this field contains the length, in
    bytes, of the data to be read.</p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p> </p>
  <p>In Section 2.2.21, SMB2 WRITE Request, updated the
  description of the RemainingBytes, WriteChannelInfoOffset, and
  WriteChannelInfoLength fields.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>RemainingBytes (4 bytes): For the SMB 3.x dialect
  family and the Channel field of the request contains SMB2_CHANNEL_RDMA_V1 or
  SMB2_CHANNEL_RDMA_V1_INVALIDATE, this field contains the length, in bytes, of
  the data being written.</p>
  <p>WriteChannelInfoOffset (2 bytes): For the SMB 3.x
  dialect family and the Channel field of the request contains
  SMB2_CHANNEL_RDMA_V1 or SMB2_CHANNEL_RDMA_V1_INVALIDATE, it contains the
  offset, in bytes, from the beginning of the SMB2 header to the channel data
  as specified by the Channel field of the request.</p>
  <p>WriteChannelInfoLength (2 bytes): For the SMB 3.x
  dialect family and the Channel field of the request contains SMB2_CHANNEL_RDMA_V1
  or SMB2_CHANNEL_RDMA_V1_INVALIDATE, it contains the length, in bytes, of the
  channel data as specified by the Channel field of the request.</p>
  <p> </p>
  <p>Changed to:</p>
  <p>RemainingBytes (4 bytes): For the SMB 3.x dialect
  family, if the Channel field of the request contains SMB2_CHANNEL_RDMA_V1 or
  SMB2_CHANNEL_RDMA_V1_INVALIDATE, this field contains the length, in bytes, of
  the data being written.</p>
  <p>WriteChannelInfoOffset (2 bytes): For the SMB 3.x
  dialect family, if the Channel field of the request contains SMB2_CHANNEL_RDMA_V1
  or SMB2_CHANNEL_RDMA_V1_INVALIDATE, it contains the offset, in bytes, from
  the beginning of the SMB2 header to the channel data as specified by the
  Channel field of the request.</p>
  <p>WriteChannelInfoLength (2 bytes): For the SMB 3.x
  dialect family, if the Channel field of the request contains
  SMB2_CHANNEL_RDMA_V1 or SMB2_CHANNEL_RDMA_V1_INVALIDATE, it contains the
  length, in bytes, of the channel data as specified by the Channel field of
  the request.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/22</p>
  </td>
  <td>
  <p>In Section 2.2.3.1, SMB2 NEGOTIATE_CONTEXT Request
  Values, added SMB2_TRANSPORT_CAPABILITIES value to ContextType.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>ContextType (2 bytes): Specifies the type of context
  in the Data field. This field MUST be one of the following values:</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>Value</p>
     </th>
     <th>
     <p>Meaning</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>SMB2_PREAUTH_INTEGRITY_CAPABILITIES<br><br></p>
    <p>0x0001</p>
    </td>
    <td>
    <p>The Data field contains a list of preauthentication
    integrity hash functions as well as an optional salt value, as specified in
    section 2.2.3.1.1.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_ENCRYPTION_CAPABILITIES<br><br></p>
    <p>0x0002</p>
    </td>
    <td>
    <p>The Data field contains a list of encryption
    algorithms, as specified in section 2.2.3.1.2.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_COMPRESSION_CAPABILITIES<br><br></p>
    <p>0x0003</p>
    </td>
    <td>
    <p>The Data field contains a list of compression
    algorithms, as specified in section 2.2.3.1.3&lt;13&gt;.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_NETNAME_NEGOTIATE_CONTEXT_ID 0x0005</p>
    </td>
    <td>
    <p>The Data field contains the server name to which the
    client connects.&lt;14&gt;<br><br></p>
    <p> </p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p>Changed to:</p>
  <p>ContextType (2 bytes): Specifies the type of context
  in the Data field. This field MUST be one of the following values:</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>Value</p>
     </th>
     <th>
     <p>Meaning</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>SMB2_PREAUTH_INTEGRITY_CAPABILITIES<br><br></p>
    <p>0x0001</p>
    </td>
    <td>
    <p>The Data  field contains a list of preauthentication
    integrity hash functions as well  as an optional salt value, as specified
    in section 2.2.3.1.1.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_ENCRYPTION_CAPABILITIES<br><br></p>
    <p>0x0002</p>
    </td>
    <td>
    <p>The Data  field contains a list of encryption
    algorithms, as specified in section 2.2.3.1.2.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_COMPRESSION_CAPABILITIES<br><br></p>
    <p>0x0003</p>
    </td>
    <td>
    <p>The Data field contains a list of compression
    algorithms, as specified in section 2.2.3.1.3&lt;13&gt;.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_NETNAME_NEGOTIATE_CONTEXT_ID 0x0005</p>
    </td>
    <td>
    <p>The Data field contains the server name to which the
    client connects&lt;14&gt;.</p>
    </td>
   </tr>
   <tr>
    <td>
    <p>SMB2_TRANSPORT_CAPABILITIES<br><br></p>
    <p>0x0006</p>
    </td>
    <td>
    <p>The Data field contains transport capabilities, as
    specified in section 2.2.3.1.5&lt;15&gt;.<br><br></p>
    <p> </p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p> </p>
  <p>Added a new Section 2.2.3.1.5,
  SMB2_TRANSPORT_CAPABILITIES.</p>
  <p>2.2.3.1.5            
  SMB2_TRANSPORT_CAPABILITIES</p>
  <p>The SMB2_TRANSPORT_CAPABILITIES context is specified
  in an SMB2 NEGOTIATE request to indicate transport capabilities over which
  the connection is made. The server MUST ignore the context on receipt. The
  format of the data in the Data field of this SMB2_NEGOTIATE_CONTEXT is as
  follows.</p>
  <p> </p>
  <p><img id="Picture 380" src="ms-winerrata_files/image008.png"></p>
  <p>Reserved (4 bytes): This field SHOULD be set to zero
  and is ignored on receipt.</p>
  <p> </p>
  <p>In Section 6, Appendix : Product Behavior, added a new
  product behavior note to support a new value.</p>
  <p> </p>
  <p>&lt;15&gt; Section 2.2.3.1: Windows 10 v1909 operating
  system and prior and Windows Server v1909 operating system and prior do not
  send or process SMB2_TRANSPORT_CAPABILITIES.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/22</p>
  </td>
  <td>
  <p>In Section 3.2.1.9, Per Server, added abstract data
  model element CipherId.</p>
  <p> </p>
  <p>Changed from :</p>
  <p>ServerName: A Unicode UTF-16 fully qualified domain
  name, a NetBIOS name, or an IP address of the server machine.</p>
  <p> </p>
  <p>Changed to:</p>
  <p>ServerName: A Unicode UTF-16 fully qualified domain
  name, a NetBIOS name, or an IP address of the server machine.</p>
  <p>CipherId: The encryption algorithm that was negotiated
  between client and server.</p>
  <p> </p>
  <p>In Section 3.2.4.2.2.2, SMB2 Only Negotiate, updated
  processing rules for CipherId.</p>
  <p> </p>
  <p>Changed from:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If
  IsEncryptionSupported is TRUE, it MUST do the following:</p>

<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<p>&#9679; Increment
  NegotiateContextCount by 1.</p>
</dd>
<dd>
<p>&#9679; Add an
  SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_ENCRYPTION_CAPABILITIES to
  the negotiate request as specified in section 2.2.3.1 and initialize the
  Ciphers field with the ciphers supported by the client in the order of
  preference.&lt;107&gt;</p>
</dd></dl></dd></dl></dd></dl></dd></dl></dd></dl>
  
  
  <p> </p>
  <p>Changed to:</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; If IsEncryptionSupported
  is TRUE, it MUST do the following:</p>

<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<p>&#9679; Increment
  NegotiateContextCount by 1.</p>
</dd>
<dd>
<p>&#9679; Add an
  SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_ENCRYPTION_CAPABILITIES to
  the negotiate request as specified in section 2.2.3.1.</p>
</dd>
<dd>
<p>&#9679; If an alternate connection
  is being established to an already connected Server, set Ciphers to
  Server.CipherId and CipherCount to 1. Otherwise, set Ciphers with the ciphers
  supported by the client, if any, in the order of preference and CipherCount
  to number of ciphers in Ciphers field.&lt;107&gt;</p>
</dd></dl></dd></dl></dd></dl></dd></dl></dd></dl>
  
  
  
  <p> </p>
  <p>In Section 3.2.5.2, Receiving an SMB NEGOTIATE
  Response, updated processing rules for CipherId.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>&#9679; Processing the SMB2_ENCRYPTION_CAPABILITIES
  negotiate context</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; The client MUST
  return an error to the calling application in the following cases:</p>

<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<p>&#9679;</p>
</dd></dl></dd></dl></dd></dl></dd></dl></dd></dl>
  
  <p>The DataLength of the negotiate context is less than
  the size of SMB2_ENCRYPTION_CAPABILITIES structure.</p>
  <dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<p>&#9679; CipherCount is not
  1.</p>
</dd>
<dd>
<p>&#9679; Ciphers[0] is not 0
  and not one of the ciphers that the client specified in its negotiate request.</p>
</dd></dl></dd></dl></dd></dl></dd>
<dd>
<p>&#9679; The client MUST set
  Connection.CipherId to Ciphers[0].</p>
</dd>
<dd>
<p>&#9679; If
  Connection.CipherId is nonzero, the client MUST set
  Connection.SupportsEncryption to TRUE. Otherwise, it MUST be set to FALSE.</p>
</dd></dl></dd></dl>
  
  
  
  <p> </p>
  <p>Changed to:</p>
  <p>&#9679; Processing the SMB2_ENCRYPTION_CAPABILITIES
  negotiate context</p>
  <dl>
<dd>
<dl>
<dd>
<p>&#9679; The client MUST
  return an error to the calling application in the following cases:</p>

<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<p>&#9679; The DataLength of
  the negotiate context is less than the size of SMB2_ENCRYPTION_CAPABILITIES
  structure.</p>
</dd>
<dd>
<p>&#9679; CipherCount is not
  1.</p>
</dd>
<dd>
<p>&#9679; Ciphers[0] is not 0
  and not one of the ciphers that the client specified in its negotiate
  request.</p>
</dd></dl></dd></dl></dd></dl></dd>
<dd>
<p>&#9679; The client MUST set
  Connection.CipherId to Ciphers[0] and if Server.CipherId is empty, set
  Server.CipherId to Ciphers[0].</p>
</dd>
<dd>
<p>&#9679; If
  Connection.CipherId is nonzero, the client MUST set Connection.SupportsEncryption
  to TRUE. Otherwise, it MUST be set to FALSE.</p>
</dd></dl></dd></dl>
  
  
  
  
  
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/22</p>
  </td>
  <td>
  <p>Added a new Section 3.3.5.15.19, Handling a Set Read
  CopyNumber Request.</p>
  <p> </p>
  <p> 3.3.5.15.19     
  Handling a Set Read CopyNumber Request</p>
  <p>This section applies only to servers that implement
  the SMB 3.1.1 dialect.</p>
  <p>When the server receives a request that contains an
  SMB2 header with a Command value equal to SMB2 IOCTL and a CtlCode of
  FSCTL_MARK_HANDLE, message handling proceeds as follows:</p>
  <p>If the InputCount in SMB2 IOCTL request is less than
  the size of FSCTL_MARK_HANDLE request, as specified in [MS-FSCC] section
  2.3.31, the server MUST fail the request with STATUS_INVALID_PARAMETER.</p>
  <p>The server MUST fail the request with
  STATUS_NOT_SUPPORTED in the following cases:</p>
  <p>&#9679; If Connection.Dialect is &quot;2.0.2&quot;,
  &quot;2.1&quot;, “3.0” or &quot;3.0.2&quot;.</p>
  <p>&#9679; If HandleInfo received in the request is not
  one of the values defined in [MS-FSCC] section 2.3.31.</p>
  <p>The server MUST process this request as a pass-through
  operation as specified in section 3.3.5.15.8.</p>
  <p> </p>
  <p>In Section 3.3.5.15, Receiving an SMB2 IOCTL Request:
  updated PBN#324, adding FSCTL_MARK_HANDLE.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>Windows 10 and later and Windows Server 2016 and later
  allow the additional CtlCode value, as specified in [MS-FSCC].</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>FSCTL name</p>
     </th>
     <th>
     <p>FSCTL function number</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>FSCTL_DUPLICATE_EXTENTS_TO_FILE</p>
    </td>
    <td>
    <p>0x98344<br><br></p>
    <p>Windows 10 v1803 operating system and later and
    Windows Server v1803 operating system and later allow the additional
    CtlCode value, as specified in [MS-FSCC].</p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p> </p>
  <p>Changed to:</p>
  <p>Windows 10 and later and Windows Server 2016 and later
  allow the additional CtlCode value, as specified in [MS-FSCC].</p>
  <table>
   <thead>
    <tr>
     <th>
     <p>FSCTL name</p>
     </th>
     <th>
     <p>FSCTL function number</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>FSCTL_DUPLICATE_EXTENTS_TO_FILE</p>
    </td>
    <td>
    <p>0x98344<br><br></p>
    <p>Windows 10 v1607 operating system and later and
    Windows Server 2016 operating system and later allow the additional CtlCode
    value, as specified in [MS-FSCC].</p>
    </td>
   </tr>
  </table>
  <p> </p>
  <table>
   <thead>
    <tr>
     <th>
     <p>FSCTL name</p>
     </th>
     <th>
     <p>FSCTL function number</p>
     </th>
    </tr>
   </thead>
   <tr>
    <td>
    <p>FSCTL_MARK_HANDLE</p>
    </td>
    <td>
    <p>0x900FC<br><br></p>
    <p>[A1] Windows 10 v1803 operating system and
    later and Windows Server v1803 operating system and later allow the
    additional CtlCode value, as specified in [MS-FSCC].</p>
    </td>
   </tr>
  </table>
  <p> </p>
  <p> </p>
  <p>In Section 3.3.5.15.8, Handling a Pass Through
  Operation Request: updated PBN #341 updating the information for
  FSCTL_MARK_HANDLE (0x000900FC).</p>
  <p> </p>
  <p>Changed from:</p>
  <p>FSCTL_OPLOCK_BREAK_NOTIFY (0x00090014)</p>
  <p>FSCTL_MOVE_FILE (0x00090074)</p>
  <p>FSCTL_MARK_HANDLE (0x000900FC)</p>
  <p>FSCTL_QUERY_RETRIEVAL_POINTERS (0x0009003B)</p>
  <p>FSCTL_PIPE_ASSIGN_EVENT (0x00110000)</p>
  <p>FSCTL_GET_VOLUME_BITMAP (0x0009006F)</p>
  <p>FSCTL_GET_NTFS_FILE_RECORD (0x00090068)</p>
  <p>FSCTL_INVALIDATE_VOLUMES (0x00090054)</p>
  <p>FSCTL_READ_USN_JOURNAL (0x000900BB)</p>
  <p>FSCTL_CREATE_USN_JOURNAL (0x000900E7)</p>
  <p>FSCTL_QUERY_USN_JOURNAL (0x000900F4)</p>
  <p>FSCTL_DELETE_USN_JOURNAL (0x000900F8)</p>
  <p>FSCTL_ENUM_USN_DATA (0x000900B3)</p>
  <p>FSCTL_QUERY_DEPENDENT_VOLUME (0x000901F0)</p>
  <p>FSCTL_SD_GLOBAL_CHANGE (0x000901F4)</p>
  <p>FSCTL_GET_BOOT_AREA_INFO (0x00090230)</p>
  <p>FSCTL_GET_RETRIEVAL_POINTER_BASE (0x00090234)</p>
  <p>FSCTL_SET_PERSISTENT_VOLUME_STATE (0x00090238)</p>
  <p>FSCTL_QUERY_PERSISTENT_VOLUME_STATE (0x0009023C)</p>
  <p>FSCTL_REQUEST_OPLOCK (0x00090240)</p>
  <p>FSCTL_TXFS_MODIFY_RM (0x00098144)</p>
  <p>FSCTL_TXFS_QUERY_RM_INFORMATION (0x00094148)</p>
  <p>FSCTL_TXFS_ROLLFORWARD_REDO (0x00098150)</p>
  <p>FSCTL_TXFS_ROLLFORWARD_UNDO (0x00098154)</p>
  <p>FSCTL_TXFS_START_RM (0x00098158)</p>
  <p>FSCTL_TXFS_SHUTDOWN_RM (0x0009815C)</p>
  <p>FSCTL_TXFS_READ_BACKUP_INFORMATION (0x00094160)</p>
  <p>FSCTL_TXFS_WRITE_BACKUP_INFORMATION (0x00098164)</p>
  <p>FSCTL_TXFS_CREATE_SECONDARY_RM (0x00098168)</p>
  <p>FSCTL_TXFS_GET_METADATA_INFO (0x0009416C)</p>
  <p>FSCTL_TXFS_GET_TRANSACTED_VERSION (0x00094170)</p>
  <p>FSCTL_TXFS_SAVEPOINT_INFORMATION (0x00098178)</p>
  <p>FSCTL_TXFS_CREATE_MINIVERSION (0x0009817C)</p>
  <p>FSCTL_TXFS_TRANSACTION_ACTIVE (0x0009418C)</p>
  <p>FSCTL_TXFS_LIST_TRANSACTIONS (0x000941E4)</p>
  <p>FSCTL_TXFS_READ_BACKUP_INFORMATION2 (0x000901F8)</p>
  <p>FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 (0x00090200)</p>
  <p>FSCTL_QUERY_FILE_REGIONS (0x00090284)</p>
  <p>FSCTL_IS_CSV_FILE (0x00090248)</p>
  <p>FSCTL_IS_FILE_ON_CSV_VOLUME (0x0009025C)</p>
  <p> </p>
  <p>Windows Vista SP1, Windows 7, Windows Server 2008, and
  Windows Server 2008 R2 fail FSCTLs whose transfer type is METHOD_NEITHER with
  error STATUS_NOT_SUPPORTED except the following ones. For more information
  about FSCTL transfer type, see [MSDN-IoCtlCodes].</p>
  <p> </p>
  <p>FSCTL_PIPE_TRANSCEIVE (0x0011C017)</p>
  <p> </p>
  <p>Changed to:</p>
  <p>FSCTL_OPLOCK_BREAK_NOTIFY (0x00090014)</p>
  <p>FSCTL_MOVE_FILE (0x00090074)</p>
  <p>FSCTL_QUERY_RETRIEVAL_POINTERS (0x0009003B)</p>
  <p>FSCTL_PIPE_ASSIGN_EVENT (0x00110000)</p>
  <p>FSCTL_GET_VOLUME_BITMAP (0x0009006F)</p>
  <p>FSCTL_GET_NTFS_FILE_RECORD (0x00090068)</p>
  <p>FSCTL_INVALIDATE_VOLUMES (0x00090054)</p>
  <p>FSCTL_READ_USN_JOURNAL (0x000900BB)</p>
  <p>FSCTL_CREATE_USN_JOURNAL (0x000900E7)</p>
  <p>FSCTL_QUERY_USN_JOURNAL (0x000900F4)</p>
  <p>FSCTL_DELETE_USN_JOURNAL (0x000900F8)</p>
  <p>FSCTL_ENUM_USN_DATA (0x000900B3)</p>
  <p>FSCTL_QUERY_DEPENDENT_VOLUME (0x000901F0)</p>
  <p>FSCTL_SD_GLOBAL_CHANGE (0x000901F4)</p>
  <p>FSCTL_GET_BOOT_AREA_INFO (0x00090230)</p>
  <p>FSCTL_GET_RETRIEVAL_POINTER_BASE (0x00090234)</p>
  <p>FSCTL_SET_PERSISTENT_VOLUME_STATE (0x00090238)</p>
  <p>FSCTL_QUERY_PERSISTENT_VOLUME_STATE (0x0009023C)</p>
  <p>FSCTL_REQUEST_OPLOCK (0x00090240)</p>
  <p>FSCTL_TXFS_MODIFY_RM (0x00098144)</p>
  <p>FSCTL_TXFS_QUERY_RM_INFORMATION (0x00094148)</p>
  <p>FSCTL_TXFS_ROLLFORWARD_REDO (0x00098150)</p>
  <p>FSCTL_TXFS_ROLLFORWARD_UNDO (0x00098154)</p>
  <p>FSCTL_TXFS_START_RM (0x00098158)</p>
  <p>FSCTL_TXFS_SHUTDOWN_RM (0x0009815C)</p>
  <p>FSCTL_TXFS_READ_BACKUP_INFORMATION (0x00094160)</p>
  <p>FSCTL_TXFS_WRITE_BACKUP_INFORMATION (0x00098164)</p>
  <p>FSCTL_TXFS_CREATE_SECONDARY_RM (0x00098168)</p>
  <p>FSCTL_TXFS_GET_METADATA_INFO (0x0009416C)</p>
  <p>FSCTL_TXFS_GET_TRANSACTED_VERSION (0x00094170)</p>
  <p>FSCTL_TXFS_SAVEPOINT_INFORMATION (0x00098178)</p>
  <p>FSCTL_TXFS_CREATE_MINIVERSION (0x0009817C)</p>
  <p>FSCTL_TXFS_TRANSACTION_ACTIVE (0x0009418C)</p>
  <p>FSCTL_TXFS_LIST_TRANSACTIONS (0x000941E4)</p>
  <p>FSCTL_TXFS_READ_BACKUP_INFORMATION2 (0x000901F8)</p>
  <p>FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 (0x00090200)</p>
  <p>FSCTL_QUERY_FILE_REGIONS (0x00090284)</p>
  <p>FSCTL_IS_CSV_FILE (0x00090248)</p>
  <p>FSCTL_IS_FILE_ON_CSV_VOLUME (0x0009025C)</p>
  <p> </p>
  <p>Windows 10 v1511 operating system and prior and
  Windows Server 2012 R2 operating system and prior block FSCTL_MARK_HANDLE
  (0x000900FC) and do not pass it through to the object store. The request is
  failed with STATUS_NOT_SUPPORTED.</p>
  <p> </p>
  <p>Windows Vista SP1, Windows 7, Windows Server 2008, and
  Windows Server 2008 R2 fail FSCTLs whose transfer type is METHOD_NEITHER with
  error STATUS_NOT_SUPPORTED except the following ones. For more information
  about FSCTL transfer type, see [MSDN-IoCtlCodes].</p>
  <p> </p>
  <p>FSCTL_PIPE_TRANSCEIVE (0x0011C017)</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/08</p>
  </td>
  <td>
  <p>In Section 3.2.1.7, Per Pending Request, added a
  definition forRequest.BufferDescriptorList.</p>
  <p> </p>
  <p>Changed from:</p>
  <p>Request.Timestamp: The time at which the request was
  sent to the server.</p>
  <p> </p>
  <p>Changed to:</p>
  <p>Request.Timestamp: The time at which the request was
  sent to the server.</p>
  <p> </p>
  <p>If the client implements the SMB 3.x dialect family,
  it also implements the following:</p>
  <p> </p>
  <p>Request.BufferDescriptorList: For a READ/WRITE request
  sent over RDMA, this is a list of SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures
  returned by [MS-SMBD] section 3.1.4.3.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/06/08</p>
  </td>
  <td>
  <p>In Section 3.3.5.4, Receiving an SMB2 NEGOTIATE
  Request, the following has been changed from:</p>
  <p> </p>
  <p>&#9679; Building an SMB2_COMPRESSION_CAPABILITIES
  negotiate response context:</p>
  <p>&#9679; If the server processed the
  SMB2_COMPRESSION_CAPABILITIES negotiate request context, then the server MUST
  build an SMB2_COMPRESSION_CAPABILITIES negotiate response context by setting
  the following:</p>
  <p>&#9679; If Connection.CompressionIds is empty,</p>
  <p>&#9679; Set CompressionAlgorithmCount to 1.Set
  CompressionAlgorithms to &quot;NONE&quot;.</p>
  <p>&#9679; Otherwise,</p>
  <p>&#9679; Set CompressionAlgorithmCount to the number of
  compression algorithms in Connection.CompressionIds.</p>
  <p>&#9679; Set CompressionAlgorithms to
  Connection.CompressionIds.</p>
  <p>&#9679; If IsChainedCompressionSupported is TRUE and
  SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED bit is set in Flags field of
  negotiate request context, SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED bit MUST
  be set in Flags field and Connection.SupportsChainedCompression MUST be set
  to TRUE.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679; Building an SMB2_COMPRESSION_CAPABILITIES
  negotiate response context:</p>
  <p>&#9679; If the server processed the
  SMB2_COMPRESSION_CAPABILITIES negotiate request context, then the server MUST
  build an SMB2_COMPRESSION_CAPABILITIES negotiate response context by setting
  the following:</p>
  <p>&#9679; If IsChainedCompressionSupported is TRUE and
  SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED bit is set in Flags field of
  negotiate request context, SMB2_COMPRESSION_CAPABILITIES_FLAG_CHAINED bit
  MUST be set in Flags field and Connection.SupportsChainedCompression MUST be
  set to TRUE.</p>
  <p>&#9679; If Connection.CompressionIds is empty,</p>
  <p>&#9679; Set CompressionAlgorithmCount to 1.</p>
  <p>&#9679; Set CompressionAlgorithms to &quot;NONE&quot;.</p>
  <p>&#9679; Otherwise,</p>
  <p>&#9679; Set CompressionAlgorithmCount to the number of
  compression algorithms in Connection.CompressionIds.</p>
  <p>&#9679; Set CompressionAlgorithms to
  Connection.CompressionIds.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p><b>For a Diff of the below changes, see the PDF doc </b><a href="https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-SMB2/%5bMS-SMB2%5d_200525_errata_diff.pdf"><b>here</b></a><b>.</b></p>
  <p> </p>
  <p>In Section 6, Appendix A: Product Behavior, product
  behavior note &lt;341&gt; for Section 3.3.5.15.8 was changed from:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>FSCTL_IS_FILE_ON_CSV_VOLUME (0x0009025C)</p>
  <p> </p>
  <p>Windows-based SMB2 servers fail FSCTLs  whose
  transfer type is METHOD_NEITHER with error STATUS_NOT_SUPPORTED except the
  following ones. For more information about FSCTL transfer type, see
  [MSDN-IoCtlCodes].</p>
  <p> </p>
  <p>FSCTL_PIPE_TRANSCEIVE (0x0011C017)</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>FSCTL_IS_FILE_ON_CSV_VOLUME (0x0009025C)</p>
  <p> </p>
  <p>Windows Vista SP1, Windows 7, Windows Server 2008, and
  Windows Server 2008 R2 fail FSCTLs  whose transfer type is
  METHOD_NEITHER with error STATUS_NOT_SUPPORTED except the following ones. For
  more information about FSCTL transfer type, see [MSDN-IoCtlCodes].</p>
  <p> </p>
  <p>FSCTL_PIPE_TRANSCEIVE (0x0011C017)</p>
  <p>...</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p>In Section 3.1.5.3, Decompressing the Chained Message,
  the following was changed from:</p>
  <p> </p>
  <p>If IsCompressionSupported is FALSE,
  Connection.SupportsChainedCompression is FALSE, or Connection.CompressionIds
  is empty, the receiver MUST skip the processing in this section.</p>
  <p> </p>
  <p>1.   The sender MUST initialize
  RemainingCompressedDataSize with the size of the received compressed SMB2
  message and DecompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2.   The compressed message MUST be decompressed until
  the size of RemainingCompressedDataSize is greater than the size of
  SMB2COMPRESSION_PAYLOAD_HEADER:</p>
  <p> </p>
  <p>&#9679;   The first 8 bytes of the data MUST be
  interpreted as SMB2_COMPRESSION_PAYLOAD_HEADER, specified in section
  2.2.42.1.</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId in
  SMB2_COMPRESSION_PAYLOAD_HEADER is not one of the values specified in section
  2.2.3.1.3, the connection MUST be disconnected as specified in section
  3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId in
  SMB2_COMPRESSION_PAYLOAD_HEADER is NONE:</p>
  <p> </p>
  <p>&#9679;   If Length is greater than (the size of the
  received compressed message – 8) or OriginalCompressedSegmentSize in SMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   Length number of bytes following
  SMB2_COMPRESSION_PAYLOAD_HEADER MUST be interpreted as uncompressed data and
  MUST be appended to DecompressedMessage.</p>
  <p> </p>
  <p>&#9679;   Otherwise, the data MUST be decompressed as
  follows:</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId is Pattern_V1, the next 8
  bytes MUST be interpreted as SMB2_COMPRESSION_PATTERN_PAYLOAD_V1, specified
  in section 2.2.42.2.</p>
  <p> </p>
  <p>&#9679;   If Repetitions in
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1 is greater than OriginalCompressedSegmentSize
  in SMB2 COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   Otherwise, DecompressedMessage MUST be
  appended with Repetitions number of bytes initialized with the character
  specified in Pattern field.</p>
  <p> </p>
  <p>&#9679;   Otherwise, the data of size specified in
  Length field MUST be decompressed using the algorithm specified in
  AlgorithmId field as specified in [MS-XCA] section 2. DecompressedMessage
  MUST be appended with the decompressed data.</p>
  <p> </p>
  <p>&#9679;   RemainingCompressedDataSize MUST be
  decremented by the size in Length field.</p>
  <p> </p>
  <p>3.   DecompressedMessage MUST be returned.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If IsCompressionSupported is FALSE,
  Connection.SupportsChainedCompression is FALSE, or Connection.CompressionIds
  is empty, the receiver MUST skip the processing in this section.</p>
  <p> </p>
  <p>1.   The receiver MUST initialize
  RemainingCompressedDataSize with the size of the received compressed SMB2
  message and DecompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2.   If the size of RemainingCompressedDataSize is
  greater than the size of SMB2_COMPRESSION_PAYLOAD_HEADER, the compressed
  message MUST be decompressed as follows:</p>
  <p> </p>
  <p>&#9679;   The first 8 bytes of the data MUST be
  interpreted as SMB2_COMPRESSION_PAYLOAD_HEADER, specified in section
  2.2.42.1.</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId in
  SMB2_COMPRESSION_PAYLOAD_HEADER is not one of the values specified in section
  2.2.3.1.3, the connection MUST be disconnected as specified in section
  3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId in SMB2_COMPRESSION_PAYLOAD_HEADER
  is NONE:</p>
  <p> </p>
  <p>&#9679;   If Length is greater than (the size of the
  received compressed message – 8) or OriginalCompressedSegmentSize in SMB2
  COMPRESSION_TRANSFORM_HEADER, the connection MUST be disconnected as
  specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   Length number of bytes following
  SMB2_COMPRESSION_PAYLOAD_HEADER MUST be interpreted as uncompressed data and
  MUST be appended to DecompressedMessage.</p>
  <p> </p>
  <p>&#9679;   Otherwise, the data MUST be decompressed as
  follows:</p>
  <p> </p>
  <p>&#9679;   If AlgorithmId is Pattern_V1, the next 8
  bytes MUST be interpreted as SMB2_COMPRESSION_PATTERN_PAYLOAD_V1, specified
  in section 2.2.42.2.</p>
  <p> </p>
  <p>&#9679;   If Repetitions in
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1 is greater than
  OriginalCompressedSegmentSize in SMB2 COMPRESSION_TRANSFORM_HEADER, the connection
  MUST be disconnected as specified in section 3.2.7.1 or 3.3.7.1.</p>
  <p> </p>
  <p>&#9679;   Otherwise, DecompressedMessage MUST be
  appended with Repetitions number of bytes initialized with the character
  specified in Pattern field.</p>
  <p> </p>
  <p>&#9679;   Otherwise, the data of size specified in
  Length field MUST be decompressed using the algorithm specified in
  AlgorithmId field as specified [MS-XCA] section 2. DecompressedMessage MUST
  be appended with the decompressed data.</p>
  <p> </p>
  <p>&#9679;   RemainingCompressedDataSize MUST be
  decremented by the size in Length field.</p>
  <p> </p>
  <p>&#9679;   If the size of RemainingCompressedDataSize
  is greater than the size of SMB2_COMPRESSION_PAYLOAD_HEADER, the receiver
  MUST repeat step 2.</p>
  <p> </p>
  <p>3.   DecompressedMessage MUST be returned.</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p>In Section 3.1.4.4, Compressing the Message, the
  following was changed from:</p>
  <p> </p>
  <p>1.   The sender MUST initialize
  RemainingUncompressedDataSize with the size of uncompressed SMB2 message,
  TotalCompressedDataSize with 0, and CompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2.   The message MUST be compressed until
  RemainingUncompressedDataSize is greater than zero:</p>
  <p> </p>
  <p>&#9679;   If Connection.CompressionIds includes
  Pattern_V1, message MUST be scanned for data patterns as specified in section
  3.1.4.4.1. If the returned FrontDataPattern.Repetitions is greater than zero,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with front data pattern returned by
  section 3.1.4.4.1. RemainingUncompressedDataSize MUST be decremented by
  FrontDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  FrontDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679;   If RemainingUncompressedDataSize is greater
  than 1024, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to first preferred
  algorithm in Connection.CompressionIds. The data MUST be compressed using the
  algorithm specified in AlgorithmId as specified in [MS-XCA] section 2. Length
  MUST be set to the size of the compressed data. A 4-byte field, indicating
  the size of the original plain text size of the data compressed, MUST be
  appended to CompressedMessage. CompressedMessage MUST be appended with the compressed
  data. RemainingUncompressedDataSize MUST be decremented by the size of data
  before compression. TotalCompressedDataSize MUST be incremented by the size
  of compressed data.</p>
  <p> </p>
  <p>&#9679;   Otherwise if RemainingUncompressedDataSize
  is greater than zero, if (size of the uncompressed SMB2 message /
  RemainingUncompressedDataSize) is greater than 2, CompressedMessage MUST be
  appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId
  MUST be set to NONE. Length MUST be set to RemainingUncompressedDataSize.
  CompressedMessage MUST be appended with the Remaining uncompressed data.
  RemainingUncompressedDataSize MUST be decremented by the size of data before
  compression. TotalCompressedDataSize MUST be incremented by the size of
  compressed data.</p>
  <p> </p>
  <p>&#9679;   If BackDataPattern.Repetitions is greater
  than zero, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1. CompressedMessage
  MUST be appended with BackDataPattern returned by section 3.1.4.4.1.
  RemainingUncompressedDataSize MUST be decremented by
  BackDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  BackDataPattern.Repetitions.</p>
  <p> </p>
  <p>3.   If TotalCompressedDataSize+8 is less than the
  size of uncompressed SMB2 message, the sender MUST prepend CompressedMessage
  with first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2 message.</p>
  <p> </p>
  <p>4.   Otherwise, the uncompressed SMB2 message is sent.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>1.   The sender MUST initialize
  RemainingUncompressedDataSize with the size of uncompressed SMB2 message,
  TotalCompressedDataSize with 0, and CompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2.   If RemainingUncompressedDataSize is greater than
  zero, the message MUST be compressed as follows:</p>
  <p> </p>
  <p>&#9679;   If Connection.CompressionIds includes
  Pattern_V1, message MUST be scanned for data patterns as specified in section
  3.1.4.4.1. If the returned FrontDataPattern.Repetitions is greater than zero,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with front data pattern returned by
  section 3.1.4.4.1. RemainingUncompressedDataSize MUST be decremented by
  FrontDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  FrontDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679;   If RemainingUncompressedDataSize is greater
  than 1024, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to first preferred
  algorithm in Connection.CompressionIds. The data MUST be compressed using the
  algorithm specified in AlgorithmId as specified in [MS-XCA] section 2. Length
  MUST be set to the size of the compressed data. A 4-byte field, indicating
  the size of the original plain text size of the data compressed, MUST be
  appended to CompressedMessage. CompressedMessage MUST be appended with the
  compressed data. RemainingUncompressedDataSize MUST be decremented by the
  size of data before compression. TotalCompressedDataSize MUST be incremented
  by the size of compressed data.</p>
  <p> </p>
  <p>&#9679;   Otherwise if RemainingUncompressedDataSize
  is greater than zero, if (size of the uncompressed SMB2 message /
  RemainingUncompressedDataSize) is greater than 2, CompressedMessage MUST be
  appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId
  MUST be set to NONE. Length MUST be set to RemainingUncompressedDataSize.
  CompressedMessage MUST be appended with the Remaining uncompressed data.
  RemainingUncompressedDataSize MUST be decremented by the size of data before
  compression. TotalCompressedDataSize MUST be incremented by the size of
  compressed data.</p>
  <p> </p>
  <p>&#9679;   If BackDataPattern.Repetitions is greater
  than zero, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with BackDataPattern returned by section
  3.1.4.4.1. RemainingUncompressedDataSize MUST be decremented by
  BackDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  BackDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679;   If RemainingUncompressedDataSize is greater
  than zero, the sender MUST repeat step 2.</p>
  <p> </p>
  <p>3.   If TotalCompressedDataSize+8 is less than the
  size of uncompressed SMB2 message, the sender MUST prepend CompressedMessage
  with first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2
  message. Otherwise, the uncompressed SMB2 message is sent.</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p>In Section 2.2.42.1, SMB2_COMPRESSION_PAYLOAD_HEADER, the
  following was changed from:</p>
  <p> </p>
  <p>The SMB2_COMPRESSION_PAYLOAD_HEADER is used by the
  client or server when sending chained compressed payloads. This structure
  MUST start at an 8-byte aligned boundary relative to the start of the
  message. This optional structure is only valid for the SMB 3.1.1
  dialect&lt;70&gt;.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>The SMB2_COMPRESSION_PAYLOAD_HEADER is used by the
  client or server when sending chained compressed payloads. This optional
  structure is only valid for the SMB 3.1.1 dialect&lt;70&gt;.</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p>In Section 2.2.42.1, SMB2_COMPRESSION_PAYLOAD_HEADER,
  a new field was added:</p>
  <p> </p>
  <p>OriginalPayloadSize (4 bytes): This optional field is
  present only when AlgorithmId is LZNT1, LZ77, or LZ77+Huffman. The size, in
  bytes, of the uncompressed payload.</p>
  <p> </p>
  <p>Section 3.1.4.4 Compressing the Message was changed
  from:</p>
  <p> </p>
  <p>If IsCompressionSupported is FALSE or
  Connection.CompressionIds is empty, the sender MUST skip the processing in
  this section.</p>
  <p> </p>
  <p>If Connection.SupportsChainedCompression is TRUE, the
  sender &lt;77&gt;MUST prepare the compressed message2.2.42 as the following:</p>
  <p> </p>
  <p>1. The sender MUST initialize
  RemainingUncompressedDataSize with the size of uncompressed SMB2 message,
  TotalCompressedDataSize with 0, and CompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2. If RemainingUncompressedDataSize is greater than
  zero, the message MUST be compressed as follows:</p>
  <p> </p>
  <p>&#9679; If Connection.CompressionIds includes
  Pattern_V1, message MUST be scanned for data patterns as specified in section
  3.1.4.4.1. If the returned FrontDataPattern.Repetitions is greater than zero,
  CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with front data pattern returned by
  section 3.1.4.4.1. RemainingUncompressedDataSize MUST be decremented by
  FrontDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  FrontDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679; If RemainingUncompressedDataSize is greater
  than 1024, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to first preferred
  algorithm in Connection.CompressionIds. The data MUST be compressed using the
  algorithm specified in AlgorithmId as specified in  section 2. Length
  MUST be set to the size of the compressed data. A 4-byte field, indicating
  the size of the original plain text size of the data compressed, MUST be
  appended to CompressedMessage. CompressedMessage MUST be appended with the
  compressed data. RemainingUncompressedDataSize MUST be decremented by the
  size of data before compression. TotalCompressedDataSize MUST be incremented
  by the size of compressed data.</p>
  <p> </p>
  <p>&#9679; Otherwise if RemainingUncompressedDataSize is
  greater than zero, if (size of the uncompressed SMB2 message /
  RemainingUncompressedDataSize) is greater than 2, CompressedMessage MUST be
  appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId
  MUST be set to NONE. Length MUST be set to RemainingUncompressedDataSize.
  CompressedMessage MUST be appended with the Remaining uncompressed data.
  RemainingUncompressedDataSize MUST be decremented by the size of data before
  compression. TotalCompressedDataSize MUST be incremented by the size of
  compressed data.</p>
  <p> </p>
  <p>&#9679; If BackDataPattern.Repetitions is greater than
  zero, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.
  CompressedMessage MUST be appended with BackDataPattern returned by section
  3.1.4.4.1. RemainingUncompressedDataSize MUST be decremented by
  BackDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented by
  BackDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679; If RemainingUncompressedDataSize is greater
  than zero, the sender MUST repeat step 2.</p>
  <p> </p>
  <p>3. If TotalCompressedDataSize+8 is less than the size
  of uncompressed SMB2 message, the sender MUST prepend CompressedMessage with
  first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2
  message. Otherwise, the uncompressed SMB2 message is sent.</p>
  <p> </p>
  <p>Otherwise, the sender SHOULD construct the SMB2
  COMPRESSION_TRANSFORM_HEADER specified in section  as follows:</p>
  <p> </p>
  <p>1. CompressionAlgorithm MUST be set to one from
  Connection.CompressionIds.</p>
  <p> </p>
  <p>2. The sender MAY choose to leave the leading portion
  of the SMB2 message uncompressed and compressing only the trailing portion.</p>
  <p> </p>
  <p>3. The sender MUST perform the following:</p>
  <p> </p>
  <p>&#9679; If the entire SMB2 message is being
  compressed, then set Offset to zero; otherwise, set Offset to the length, in
  bytes, of the uncompressed part of the message.</p>
  <p> </p>
  <p>&#9679; Set OriginalCompressedSegmentSize to the
  uncompressed length, in bytes, of the portion of the message that is being
  compressed.</p>
  <p> </p>
  <p>The sender MUST compress the data using the
  CompressionAlgorithm as specified in [MS-XCA] section 2.</p>
  <p> </p>
  <p>If the size of the compressed data is less than
  OriginalCompressedSegmentSize, the sender MUST perform the following:</p>
  <p> </p>
  <p>&#9679; If Offset is zero, the sender MUST replace the
  SMB2 message with the SMB2 COMPRESSION_TRANSFORM_HEADER followed by the
  compressed SMB2 message. Otherwise, the sender MUST replace the portion of
  the SMB2 message selected for compression with the compressed part and
  prepend the SMB2 message with the SMB2 COMPRESSION_TRANSFORM_HEADER.</p>
  <p> </p>
  <p>Otherwise, the uncompressed SMB2 message without the
  SMB2 COMPRESSION_TRANSFORM_HEADER is used.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If IsCompressionSupported is FALSE or Connection.CompressionIds
  is empty, the sender MUST skip the processing in this section.</p>
  <p> </p>
  <p>If Connection.SupportsChainedCompression is FALSE, the
  sender SHOULD&lt;77&gt; construct the SMB2 COMPRESSION_TRANSFORM_HEADER
  specified in section 2.2.42 as follows:</p>
  <p> </p>
  <p>1. CompressionAlgorithm MUST be set to LZNT1, LZ77, or
  LZ77+Huffman specified in Connection.CompressionIds.</p>
  <p> </p>
  <p>2. The sender MAY choose to leave the leading portion
  of the SMB2 message uncompressed and compressing only the trailing
  portion.&lt;78&gt;</p>
  <p> </p>
  <p>3. The sender MUST perform the following:</p>
  <p> </p>
  <p>&#9679; If the entire SMB2 message is being
  compressed, then set Offset to zero; otherwise, set Offset to the length, in
  bytes, of the uncompressed part of the message.</p>
  <p> </p>
  <p>&#9679; Set OriginalCompressedSegmentSize to the
  uncompressed length, in bytes, of the portion of the message that is being
  compressed.</p>
  <p> </p>
  <p>4. The sender MUST compress the data using the
  CompressionAlgorithm as specified in [MS-XCA] section 2.</p>
  <p> </p>
  <p>5. If the size of the compressed data is less than
  OriginalCompressedSegmentSize, the sender MUST perform the following:</p>
  <p> </p>
  <p>&#9679; If Offset is zero, the sender MUST replace the
  SMB2 message with the SMB2 COMPRESSION_TRANSFORM_HEADER followed by the
  compressed SMB2 message.</p>
  <p>&#9679; Otherwise, the sender MUST replace the portion
  of the SMB2 message selected for compression with the compressed part and
  prepend the SMB2 message with the SMB2 COMPRESSION_TRANSFORM_HEADER. The
  compressed SMB2 message is sent.</p>
  <p>6. Otherwise, the original, uncompressed SMB2 message
  without the SMB2 COMPRESSION_TRANSFORM_HEADER is sent.</p>
  <p>Otherwise, the sender MUST prepare the compressed
  message as follows:</p>
  <p> </p>
  <p>1. The sender MUST initialize
  RemainingUncompressedDataSize with the size of uncompressed data,
  TotalCompressedDataSize with 0, and CompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2. The uncompressed data MUST be compressed as
  follows:</p>
  <p> </p>
  <p>&#9679; If Connection.CompressionIds includes
  Pattern_V1 and RemainingUncompressedDataSize is greater than 32, the
  uncompressed data MUST be scanned for data patterns as specified in section
  3.1.4.4.1. If the returned ForwardDataPattern.Repetitions is greater than
  zero, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to Pattern_V1.
  Length MUST be set to the size of SMB2_COMPRESSION_PATTERN_PAYLOAD_V1. CompressedMessage
  MUST be appended with ForwardDataPattern. RemainingUncompressedDataSize MUST
  be decremented by ForwardDataPattern.Repetitions. If the returned
  BackwardDataPattern is not NULL and BackwardDataPattern.Repetitions is
  greater than zero, RemainingUncompressedDataSize MUST be decremented by
  BackwardDataPattern.Repetitions. TotalCompressedDataSize MUST be incremented
  by ForwardDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679; If RemainingUncompressedDataSize is greater
  than 1024, CompressedMessage MUST be appended with newly constructed
  SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId MUST be set to LZNT1, LZ77, or
  LZ77+Huffman specified in Connection.CompressionIds. The uncompressed data
  MUST be compressed using the algorithm specified in AlgorithmId as specified
  in [MS-XCA] section 2. Length MUST be set to the size of the compressed data.
  OriginalPayloadSize MUST be set to the size of the uncompressed data.
  CompressedMessage MUST be appended with the compressed data.
  RemainingUncompressedDataSize MUST be decremented by the size of data before
  compression. TotalCompressedDataSize MUST be incremented by the size of
  compressed data.</p>
  <p> </p>
  <p>&#9679; Otherwise if RemainingUncompressedDataSize is
  greater than zero and (size of the uncompressed SMB2 message /
  RemainingUncompressedDataSize) is greater than 2, CompressedMessage MUST be
  appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER. AlgorithmId
  MUST be set to NONE. Length MUST be set to RemainingUncompressedDataSize.
  CompressedMessage MUST be appended with the uncompressed data. RemainingUncompressedDataSize
  MUST be decremented by the size of data before compression.
  TotalCompressedDataSize MUST be incremented by the size of compressed data.</p>
  <p> </p>
  <p>&#9679; If BackwardDataPattern is not NULL and
  BackwardDataPattern.Repetitions is greater than zero, CompressedMessage MUST
  be appended with newly constructed SMB2_COMPRESSION_PAYLOAD_HEADER.
  AlgorithmId MUST be set to Pattern_V1. Length MUST be set to the size of
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1. CompressedMessage MUST be appended with
  BackwardDataPattern. TotalCompressedDataSize MUST be incremented by
  BackwardDataPattern.Repetitions.</p>
  <p> </p>
  <p>&#9679; If RemainingUncompressedDataSize is greater
  than zero, the sender MUST repeat step 2.</p>
  <p> </p>
  <p>3. If TotalCompressedDataSize+8 is less than the size
  of uncompressed SMB2 message, the sender MUST prepend CompressedMessage with
  first 8 bytes of SMB2 COMPRESSION_TRANSFORM_HEADER.
  OriginalCompressedSegmentSize MUST be set to the size of uncompressed SMB2
  message. The compressed SMB2 message is sent. Otherwise, the original, uncompressed
  SMB2 message is sent.</p>
  <p> </p>
  <p>Section 3.1.4.4.1, Algorithm for Scanning Data
  Patterns V1, was changed from:</p>
  <p> </p>
  <p>The inputs for this algorithm are:</p>
  <p> </p>
  <p>InputBuffer: Input data to scan data patterns</p>
  <p> </p>
  <p>InputBufferSize: Size of InputBuffer</p>
  <p> </p>
  <p>FrontScan: A Boolean value indicating if data is to be
  scanned forward (TRUE) or backward (FALSE).</p>
  <p> </p>
  <p>The output is two DataPatterns of type
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V12.2.42.2.</p>
  <p> </p>
  <p>If the length of InputBuffer is less than or equal to
  32, no pattern compression processing is performed.</p>
  <p> </p>
  <p>Scan for data patterns by setting FrontScan to TRUE as
  specified in section . Returned DataPattern MUST be interpreted as
  FrontDataPattern. FrontDataPattern.Pattern MUST be set to the first byte in
  InputBuffer.</p>
  <p> </p>
  <p>If FrontDataPattern.Repetitions is equal to
  InputBufferSize, return FrontDataPattern. Otherwise, scan for data patterns
  by setting FrontScan to FALSE as specified in section 3.1.4.4.1.1. Returned
  DataPattern MUST be interpreted as BackDataPattern. BackDataPattern.Pattern
  MUST be set to the last byte in InputBuffer.</p>
  <p> </p>
  <p>Return FrontDataPattern and BackDataPattern.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>Construct a new SMB2_COMPRESSION_PATTERN_PAYLOAD_V1
  structure, specified in section 2.2.42.2 and scan forward in the buffer for a
  consecutive series of bytes equal to the first byte:</p>
  <p> </p>
  <p>&#9679; For each consecutive byte matched,
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions MUST be incremented by 1.</p>
  <p> </p>
  <p>&#9679; If none, stop scan.</p>
  <p> </p>
  <p>If SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions is
  less than 64, SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions MUST be set to
  0. SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Pattern MUST be set to the first byte
  in the buffer.</p>
  <p> </p>
  <p>If SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions is
  equal to the size of the buffer, the processing MUST return the
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1 as ForwardDataPattern, and
  BackwardDataPattern set to NULL.</p>
  <p> </p>
  <p>Otherwise, construct a new
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1 structure, specified in section 2.2.42.2
  and scan backward in the buffer for a consecutive series of bytes equal to
  the last byte:</p>
  <p> </p>
  <p>&#9679; For each consecutive byte matched,
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions MUST be incremented by 1.</p>
  <p> </p>
  <p>&#9679; If none, stop scan.</p>
  <p> </p>
  <p>If SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions is
  less than 64, SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Repetitions MUST be set to
  0. SMB2_COMPRESSION_PATTERN_PAYLOAD_V1.Pattern MUST be set to the last byte
  in the buffer.</p>
  <p> </p>
  <p>The processing MUST return both
  SMB2_COMPRESSION_PATTERN_PAYLOAD_V1 structures respectively as ForwardDataPattern
  and BackwardDataPattern.</p>
  <p> </p>
  <p>Section 3.1.4.4.1.1, Scan for Data Patterns, was
  removed.</p>
  <p> </p>
  <p>In Section 3.1.5.3, Decompressing the Chained Message,
  the following was changed from:</p>
  <p> </p>
  <p>1. The receiver MUST initialize
  RemainingCompressedDataSize with the size of the received compressed SMB2
  message and DecompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2. If the size of RemainingCompressedDataSize is
  greater than the size of SMB2_COMPRESSION_PAYLOAD_HEADER, the compressed
  message MUST be decompressed as follows:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679; Otherwise, the data of size specified in
  Length field MUST be decompressed using the algorithm specified in
  AlgorithmId field as specified in [MS-XCA] section 2. DecompressedMessage
  MUST be appended with the decompressed data.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>1. The receiver MUST initialize
  RemainingCompressedDataSize with the size of the received compressed data and
  DecompressedMessage with empty buffer.</p>
  <p> </p>
  <p>2. The compressed data MUST be decompressed as
  follows:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679; Otherwise, the data of size specified in
  Length field MUST be decompressed using the algorithm specified in
  AlgorithmId field as specified in [MS-XCA] section 2. If the size of the
  decompressed data is not equal to OriginalPayloadSize, the connection MUST be
  disconnected as specified in section 3.2.7.1 or section 3.3.7.1.
  DecompressedMessage MUST be appended with the decompressed data.</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/25</p>
  </td>
  <td>
  <p>In Section 6, Appendix A: Product Behavior, product
  behavior note &lt;235&gt; was changed from:</p>
  <p> </p>
  <p>&lt;235&gt; Section 3.3.5.4: Windows 10 v1903 and
  later and Windows Server v1903 and later only set CompressionAlgorithms to
  the first common algorithm supported by the client and server.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&lt;235&gt; Section 3.3.5.4: Windows 10 v1903, Windows
  10 v1909, Windows Server v1903, and Windows Server v1909 only set
  CompressionAlgorithms to the first common algorithm supported by the client
  and server.</p>
  <p> </p>
  <p>Windows 10 v2004 and Windows Server v2004 select a
  common pattern scanning algorithm and the first common compression algorithm,
  specified in section 2.2.3.1.3, supported by the client and server.</p>
  <p> </p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/11</p>
  </td>
  <td>
  <p>In Section 3.3.5.9.12, Handling the
  SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 Create Context, the following was
  changed from:</p>
  <p> </p>
  <p>&#9679;   If the request includes the
  SMB2_DHANDLE_FLAG_PERSISTENT bit in the Flags field of the SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2
  create context, the server MUST look up an existing Open in the
  GlobalOpenTable by doing a lookup with the CreateGuid of the create context.
  If the lookup fails, the server SHOULD&lt;292&gt; fail the request with
  STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in &quot;Failed Open
  Handling&quot; in section 3.3.5.9.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   If the request includes the
  SMB2_DHANDLE_FLAG_PERSISTENT bit in the Flags field of the
  SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 create context, TreeConnect.Share.IsCA
  is TRUE, and Connection.ServerCapabilities includes
  SMB2_GLOBAL_CAP_PERSISTENT_HANDLES, the server MUST look up an existing Open
  in the GlobalOpenTable by doing a lookup with the CreateGuid of the create
  context. If the lookup fails, the server SHOULD&lt;292&gt; fail the request
  with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in &quot;Failed
  Open Handling&quot; in section 3.3.5.9.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/11</p>
  </td>
  <td>
  <p>In Section 3.2.5.5, Receiving an SMB2 TREE_CONNECT
  Response, step 11 in Product Behavior Note &lt;156&gt; was changed from:</p>
  <p> </p>
  <p>11. The client attempts to establish an alternate
  channel on each selected interface and address pair. The client will create
  only a single connection per address pair when the server interface is
  neither RSS- nor RDMA-capable.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>11.   By default, Windows clients create four
  connections per RSS-capable address pair or two connections per RDMA-capable
  address pair or only a single connection when the address pair is neither
  RSS-capable nor RDMA-capable.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/11</p>
  </td>
  <td>
  <p>In Section 3.2.5.3.3, Handling Session Binding, the
  following was added:</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>If SMB2_SESSION_FLAG_IS_GUEST bit is set in the
  SessionFlags field of the SMB2 SESSION_SETUP Response, the client
  SHOULD&lt;153&gt; return STATUS_INVALID_NETWORK_RESPONSE to the caller.</p>
  <p> </p>
  <p>&lt;246&gt; Section 3.3.5.6: Windows 7, Windows Server
  2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012
  R2 servers will not reset ResilientOpenScavengerExpiryTime.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>The client MUST ignore the
  SMB2_SESSION_FLAG_ENCRYPT_DATA bit in the SessionFlags field of the SMB2
  SESSION_SETUP Response.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>In Section 3.3.5.5.3, Handling GSS-API Authentication,
  the following was changed from:</p>
  <p> </p>
  <p>10.   If global EncryptData is TRUE, the server MUST
  do the following:</p>
  <p> </p>
  <p>If Connection.ServerCapabilities includes SMB2_GLOBAL_CAP_ENCRYPTION
  or RejectUnencryptedAccess is TRUE,</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>10.   If global EncryptData is TRUE,
  Connection.Dialect belongs to the SMB 3.x dialect family,
  Connection.ServerCapabilities includes SMB2_GLOBAL_CAP_ENCRYPTION,
   RejectUnencryptedAccess is TRUE, and SMB2_SESSION_FLAG_BINDING is not
  set in the Flags field of the request, the server MUST do the following:</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/11</p>
  </td>
  <td>
  <p>In Section 3.3.1.12, Per Lease the following was
  added:</p>
  <p> </p>
  <p>&#9679;   Lease.FileDeleteOnClose: A Boolean, if set
  to TRUE, indicating that file deletion on close is pending.</p>
  <p> </p>
  <p>In Section 3.3.5.9.7, Handling the
  SMB2_CREATE_DURABLE_HANDLE_RECONNECT Create Context, step 5 was changed from:</p>
  <p> </p>
  <p>5.   If Open.Lease is not NULL and Open.FileName does
  not match the file name specified in the Buffer field of the SMB2 CREATE
  request, the server MUST fail the request with STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>5.   If Open.Lease is not NULL,
  Open.Lease.FileDeleteOnClose is FALSE, and Open.Lease.FileName does not match
  the file name specified in the Buffer field of the SMB2 CREATE request, the
  server MUST fail the request with STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>In Section 3.3.5.9.8, Handling the
  SMB2_CREATE_REQUEST_LEASE Create Context, the following was added:</p>
  <p> </p>
  <p>If both SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 and
  SMB2_CREATE_REQUEST_LEASE create contexts are present in the request, they
  are processed as specified in section 3.3.5.9.12, and this section does not
  apply.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679;   Lease.FileDeleteOnClose is set to FALSE.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>If Open.Lease is not NULL and CreateOptions field in
  the CREATE request includes FILE_DELETE_ON_CLOSE, the server MUST set
  Open.Lease.FileDeleteOnClose to TRUE.</p>
  <p> </p>
  <p>The following was changed from:</p>
  <p> </p>
  <p>The server MUST attempt to locate a Lease by
  performing a lookup in the LeaseTable.LeaseList using the LeaseKey in the
  SMB2_CREATE_REQUEST_LEASE as the lookup key. If a lease is found but
  Lease.Filename does not match the file name for the incoming request, the
  request MUST be failed with STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>The server MUST attempt to locate a Lease by
  performing a lookup in the LeaseTable.LeaseList using the LeaseKey in the
  SMB2_CREATE_REQUEST_LEASE as the lookup key. If a lease is found,
  Lease.FileDeleteOnClose is FALSE, and Lease.Filename does not match the file
  name for the incoming request, the request MUST be failed with
  STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>In Section 3.3.5.9.11, Handling the
  SMB2_CREATE_REQUEST_LEASE_V2 Create Context, the following was added:</p>
  <p> </p>
  <p>If both SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 and
  SMB2_CREATE_REQUEST_LEASE_V2 create contexts are present in the request, they
  are processed as specified in section 3.3.5.9.12, and this section does not
  apply.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>&#9679;   Lease.FileDeleteOnClose is set to FALSE.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>If Open.Lease is not NULL and CreateOptions field in
  the CREATE request includes FILE_DELETE_ON_CLOSE, the server MUST set
  Open.Lease.FileDeleteOnClose to TRUE.</p>
  <p> </p>
  <p>The following paragraph was changed from:</p>
  <p> </p>
  <p>The server MUST attempt to locate a Lease by
  performing a lookup in the LeaseTable.LeaseList using the LeaseKey in the
  SMB2_CREATE_REQUEST_LEASE_V2 as the lookup key. If a lease is found but
  Lease.Filename does not match the file name for the incoming request, the
  request MUST be failed with STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>The server MUST attempt to locate a Lease by
  performing a lookup in the LeaseTable.LeaseList using the LeaseKey in the
  SMB2_CREATE_REQUEST_LEASE_V2 as the lookup key. If a lease is found ,
  Lease.FileDeleteOnClose is FALSE, and Lease.Filename does not match the file
  name for the incoming request, the request MUST be failed with
  STATUS_INVALID_PARAMETER.</p>
  <p> </p>
  <p>In Section 3.3.5.9.12, Handling the
  SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 Create Context, the following was
  changed from:</p>
  <p> </p>
  <p>&#9679;   Open.Lease is not NULL and Open.FileName
  does not match the file name specified in the Buffer field of the SMB2 CREATE
  request.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   Open.Lease is not NULL,
  Open.Lease.FileDeleteOnClose is FALSE, and Open.Lease.FileName does not match
  the file name specified in the Buffer field of the SMB2 CREATE request.</p>
  <p> </p>
  <p>In Section 3.3.5.21.1, Handling SMB2_0_INFO_FILE, the
  following was changed from:</p>
  <p> </p>
  <p>If the object store supports security and the
  information class is FileBasicInformation or FilePipeInformation, and
  Open.GrantedAccess does not include FILE_WRITE_ATTRIBUTES, the server MUST
  fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and the
  information class is FileRenameInformation, FileDispositionInformation, or
  FileShortNameInformation, and Open.GrantedAccess does not include DELETE, the
  server MUST fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and the
  information class is FileFullEaInformation, and Open.GrantedAccess does not
  include FILE_WRITE_EA, the server MUST fail the request with
  STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and the
  information class is FileFullEaInformation and the EA buffer in the Buffer
  field is not in a valid format, the server MUST fail the request with STATUS_EA_LIST_INCONSISTENT.</p>
  <p> </p>
  <p>If the object store supports security and the
  information class is FileAllocationInformation, FileEndOfFileInformation, or
  FileValidDataLengthInformation, and Open.GrantedAccess does not include
  FILE_WRITE_DATA, the server MUST fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>Otherwise, the server MUST initialize an SMB2 SET_INFO
  Response following the syntax given in section 2.2.40.</p>
  <p> </p>
  <p>If the underlying object store returns successfully,
  the information class is FileRenameInformation, Connection.Dialect is
  &quot;2.1&quot; or belongs to the SMB 3.x dialect family, the server supports
  leasing, and Open.Lease is not NULL, the server MUST update
  Open.Lease.Filename to the new name for the file.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If the object store supports security and
  FileInfoClass is FileBasicInformation or FilePipeInformation, and
  Open.GrantedAccess does not include FILE_WRITE_ATTRIBUTES, the server MUST
  fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and FileInfoClass
  is FileRenameInformation, FileDispositionInformation, or
  FileShortNameInformation, and Open.GrantedAccess does not include DELETE, the
  server MUST fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and
  FileInfoClass is FileFullEaInformation, and Open.GrantedAccess does not
  include FILE_WRITE_EA, the server MUST fail the request with
  STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>If the object store supports security and
  FileInfoClass is FileFullEaInformation and the EA buffer in the Buffer field
  is not in a valid format, the server MUST fail the request with
  STATUS_EA_LIST_INCONSISTENT.</p>
  <p> </p>
  <p>If the object store supports security and
  FileInfoClass is FileAllocationInformation, FileEndOfFileInformation, or
  FileValidDataLengthInformation, and Open.GrantedAccess does not include
  FILE_WRITE_DATA, the server MUST fail the request with STATUS_ACCESS_DENIED.</p>
  <p> </p>
  <p>...</p>
  <p> </p>
  <p>If the underlying object store returns successfully,
  FileInfoClass is FileDispositionInformation, Connection.Dialect is not
  “2.0.2” , and Open.Lease is not NULL, the server MUST set
  Open.Lease.FileDeleteOnClose to TRUE.</p>
  <p> </p>
  <p>If the underlying object store returns successfully,
  FileInfoClass is FileRenameInformation, Connection.Dialect is not “2.0.2”,
  and Open.Lease is not NULL, the server MUST update Open.Lease.Filename to the
  new name for the file and Open.Lease.FileDeleteOnClose to FALSE.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/05/11</p>
  </td>
  <td>
  <p>In Section 3.2.3, Initialization, the following was
  added:</p>
  <p> </p>
  <p>If the client implements the SMB 2.1 dialect or SMB
  3.x dialect family:</p>
  <p> </p>
  <p>The following was changed from:</p>
  <p> </p>
  <p>ClientGuid: If implemented, MUST be set to a newly
  generated GUID.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>ClientGuid: MUST be set to a newly generated GUID.</p>
  <p> </p>
  <p>In Section 3.2.4.2.2.2, SMB2-Only Negotiate, the
  following was changed from:</p>
  <p> </p>
  <p>&#9679;   If the client implements the SMB 2.1 or SMB
  3.x dialect, ClientGuid SHOULD be set to the Guid provided by the
  application. Otherwise, it MUST be set to 0. The client MUST set
  Connection.ClientGuid to the ClientGuid initialized above.  </p>
  <p> </p>
  <p>&lt;106&gt; Section 3.2.4.2.2.2:  Windows 7
  without [MSKB-3002286] sets ClientGuid to the global ClientGuid value.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>&#9679;   If the client implements the SMB 2.1 or SMB
  3.x dialect, ClientGuid MUST be set to the global ClientGuid value.
  Otherwise, it MUST be set to 0. The client MUST set Connection.ClientGuid to
  the ClientGuid initialized above.  </p>
  <p> </p>
  <p>In Section 3.3.1.5, Global, the following was added:</p>
  <p> </p>
  <p>&#9679;   GlobalClientTable: A list of clients,
  indexed by the ClientGuid as specified in section 3.3.1.16.</p>
  <p> </p>
  <p>A new Section 3.3.1.16, Per Client, was added:</p>
  <p> </p>
  <p>If the server implements the SMB 3.x dialect family,
  it implements the following:</p>
  <p> </p>
  <p>Client.ClientGuid: An identifier of the client
  machine.</p>
  <p> </p>
  <p>Client.Dialect: The dialect of SMB2 negotiated with
  the client. This value MUST be either “2.0.2”, “2.1”, “3.0”, “3.0.2”, or
  “3.1.1”.</p>
  <p> </p>
  <p>In Section 3.3.3, Initialization, the following was
  added:</p>
  <p> </p>
  <p>&#9679;   GlobalClientTable MUST be set to an empty
  list.</p>
  <p> </p>
  <p>In Section 3.3.5.5.3, Handling GSS-API Authentication,
  the following was changed from:</p>
  <p> </p>
  <p>The server MUST look up all existing connections from
  the client in the global ConnectionList where Connection.ClientGuid matches
  Session.Connection.ClientGuid. For any matching Connection, if
  Connection.Dialect is not the same as Session.Connection.Dialect, the server
  SHOULD close the newly created Session, as specified in section 3.3.4.12, by
  providing Session.SessionGlobalId as the input parameter, and fail the
  session setup request with STATUS_USER_SESSION_DELETED.</p>
  <p> </p>
  <p>&lt;243&gt; Section 3.3.5.5.3: Windows Vista SP1,
  Windows Server 2008, Windows 7, and Windows Server 2008 R2 servers do not
  fail the request if dialects do not match.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If the server implements the SMB 3.x dialect family
  and Session.Connection.Dialect is not “2.0.2”, the server MUST look up a
  client entry in GlobalClientTable using Session.Connection.ClientGuid. If no
  entry is found, the server MUST create a new Client entry by setting
  Client.ClientGuid to Session.Connection.ClientGuid and Client.Dialect to
  Session.Connection.Dialect. The server MUST insert the Client entry into
  GlobalClientTable. If an entry is found and Client.Dialect is not equal to
  Session.Connection.Dialect, the server MUST close the newly created Session,
  as specified in section 3.3.4.12, by providing Session.SessionGlobalId as the
  input parameter, and fail the session setup request with
  STATUS_USER_SESSION_DELETED.</p>
  <p> </p>
  <p>In Section 3.3.7.1, Handling Loss of a Connection, the
  following was added:</p>
  <p> </p>
  <p>If the server implements the SMB 3.x dialect family,
  the server MUST enumerate all connections in ConnectionList using the removed
  Connection.ClientGuid where Connection.Dialect is not “2.0.2”. If no
  Connection entry is found, the server MAY remove the Client entry identified
  by Connection.ClientGuid from GlobalClientTable.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/04/13</p>
  </td>
  <td>
  <p>In Section 3.3.5.6, Receiving an SMB2 LOGOFF Request,
  the following was changed from:</p>
  <p> </p>
  <p>When the server receives a request with an SMB2 header
  with a Command value equal to SMB2 LOGOFF, message handling MUST proceed as
  follows.</p>
  <p> </p>
  <p>The server MUST locate the session being logged off,
  as specified in section 3.3.5.2.9.</p>
  <p> </p>
  <p>The server MUST remove this session from the
  GlobalSessionTable and also from the Connection.SessionTable, and deregister
  the session by invoking the &lt;247&gt;event specified in [MS-SRVS] section
  3.1.6.3, providing Session.SessionGlobalId as input parameter.
  ServerStatistics.sts0_sopens MUST be decreased by 1. The server MUST close
  every Open in Session.OpenTable of the old session, where Open.IsDurable is
  FALSE and Open.IsResilient is FALSE, as specified in section 3.3.4.17. For
  all opens in Session.OpenTable where Open.IsDurable is TRUE or
  Open.IsResilient is TRUE, the server MUST set Open.Session, Open.Connection,
  and Open.TreeConnect to NULL.Any tree connects in Session.TreeConnectTable of
  the old session MUST be deregistered by invoking the event specified in
  [MS-SRVS] section 3.1.6.7, providing the tuple
  &lt;TreeConnect.Share.ServerName, TreeConnect.Share.Name&gt; and
  TreeConnect.TreeGlobalId as input parameters, and each of them MUST be freed.
  For each deregistered TreeConnect, TreeConnect.Share.CurrentUses MUST be
  decreased by 1.</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, the server MUST remove the session from each
  Channel.Connection.SessionTable in Session.ChannelList. All channels in
  Session.ChannelList MUST be removed and freed.</p>
  <p> </p>
  <p>The server MUST construct an SMB2 LOGOFF Response with
  a status code of STATUS_SUCCESS, following the syntax specified in section
  2.2.8, and send it to the client. The session itself is then freed.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>When the server receives a request with an SMB2 header
  with a Command value equal to SMB2 LOGOFF, message handling MUST proceed as
  follows.</p>
  <p> </p>
  <p>The server MUST locate the session being logged off,
  as specified in section 3.3.5.2.9.</p>
  <p> </p>
  <p>For each Open in Session.OpenTable, the server MUST
  perform the following:</p>
  <p> </p>
  <p>&#9679;   If Open.IsResilient is TRUE, the server MUST
  do the following:</p>
  <p> </p>
  <p>&#9679;   The server MUST set Open.Session,
  Open.Connection, and Open.TreeConnect to NULL.</p>
  <p> </p>
  <p>&#9679;   The server MUST set
  Open.ResilientOpenTimeout to the current time plus Open.ResiliencyTimeOut.</p>
  <p> </p>
  <p>&#9679;   The server SHOULD&lt;247&gt; start or reset
  the Resilient Open Scavenger Timer, as specified in section 3.3.2.4, under
  the following conditions:</p>
  <p> </p>
  <p>&#9679;   If the Resilient Open Scavenger Timer is not
  already active.</p>
  <p> </p>
  <p>&#9679;   If the Resilient Open Scavenger Timer is
  active and ResilientOpenScavengerExpiryTime is greater than
  Open.ResilientOpenTimeOut.</p>
  <p> </p>
  <p>In both of the preceding cases, the server MUST set
  the timer to expire at Open.ResilientOpenTimeOut and MUST set ResilientOpenScavengerExpiryTime
  to Open.ResilientOpenTimeOut.</p>
  <p> </p>
  <p>&#9679;   If Open.IsDurable is TRUE, the server MUST
  do the following:</p>
  <p> </p>
  <p>&#9679;   The server MUST set Open.Session,
  Open.Connection, and Open.TreeConnect to NULL.</p>
  <p> </p>
  <p>&#9679;   The server MUST set
  Open.DurableOpenScavengerTimeOut to the current time plus
  Open.DurableOpenTimeOut.</p>
  <p> </p>
  <p>&#9679;   The server MUST start the Durable Open
  Scavenger Timer, as specified in section 3.3.2.2.</p>
  <p> </p>
  <p>&#9679;   Otherwise the server MUST close the Open as
  specified in section 3.3.4.17.</p>
  <p> </p>
  <p>Any tree connects in Session.TreeConnectTable of the
  old session MUST be deregistered by invoking the event specified in [MS-SRVS]
  section 3.1.6.7, providing the tuple &lt;TreeConnect.Share.ServerName,
  TreeConnect.Share.Name&gt; and TreeConnect.TreeGlobalId as input parameters,
  and each of them MUST be freed. For each deregistered TreeConnect,
  TreeConnect.Share.CurrentUses MUST be decreased by 1.</p>
  <p> </p>
  <p>If Connection.Dialect belongs to the SMB 3.x dialect
  family, the server MUST remove the session from each
  Channel.Connection.SessionTable in Session.ChannelList. All channels in
  Session.ChannelList MUST be removed and freed.</p>
  <p> </p>
  <p>The server MUST remove this session from the
  GlobalSessionTable and also from the Connection.SessionTable, and deregister
  the session by invoking the event specified in [MS-SRVS] section 3.1.6.3,
  providing Session.SessionGlobalId as input parameter.
  ServerStatistics.sts0_sopens MUST be decreased by 1.</p>
  <p> </p>
  <p>The server MUST construct an SMB2 LOGOFF Response with
  a status code of STATUS_SUCCESS, following the syntax specified in section
  2.2.8, and send it to the client. The session itself is then freed.</p>
  <p> </p>
  <p>&lt;247&gt; Section 3.3.5.6: Windows 7, Windows Server
  2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012
  R2 servers will not reset ResilientOpenScavengerExpiryTime.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p>2020/04/13</p>
  </td>
  <td>
  <p>In Section 3.2.5.14.11, Handling a Network Interfaces
  Response, the following was changed from:</p>
  <p> </p>
  <p>The client MUST extract IPv4Address and IPv6Address
  addresses from each NETWORK_INTERFACE_INFO structure and MUST set
  Connection.Server.AddressList to the received values.</p>
  <p> </p>
  <p>The client MUST return the list of network interfaces
  received from the server to the calling application.</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>If the Status field of the SMB2 header of the response
  indicates an error, the client MUST return the received status code to the
  calling application.</p>
  <p> </p>
  <p>If the Status field of the SMB2 header of the response
  indicates success, the client MUST extract IPv4Address and IPv6Address
  addresses from each NETWORK_INTERFACE_INFO structure and MUST set
  Connection.Server.AddressList to the received values.</p>
  <p> </p>
  <p>In Section 3.3.5.15.11, Handling a Query Network
  Interface Request, the following was changed from:</p>
  <p> </p>
  <p>The server MUST enumerate the local network interfaces
  in an implementation-specific manner. For each IP address in each network
  interface, the server MUST construct a NETWORK_INTERFACE_INFO structure as
  specified in section 2.2.32.5, with the following values:</p>
  <p> </p>
  <p>Changed to:</p>
  <p> </p>
  <p>This section applies only to servers that implement
  the SMB 3.x dialect family.</p>
  <p> </p>
  <p>When the server receives a request with an SMB2 header
  with a Command value equal to SMB2 IOCTL and a CtlCode of
  FSCTL_QUERY_NETWORK_INTERFACE_INFO, message handling proceeds as follows:</p>
  <p> </p>
  <p>If Connection.Dialect does not belong to the SMB 3.x
  dialect family or Connection.ServerCapabilities does not include
  SMB2_GLOBAL_CAP_MULTI_CHANNEL, the server MAY fail the request with
  STATUS_NOT_SUPPORTED.</p>
  <p> </p>
  <p>Otherwise, the server MUST enumerate the local network
  interfaces in an implementation-specific manner. For each IP address in each
  network interface, the server MUST construct a NETWORK_INTERFACE_INFO
  structure as specified in section 2.2.32.5, with the following values:</p>
  </td>
 </tr>
</table>

<p>*Date format: YYYY/MM/DD</p>


                